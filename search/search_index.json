{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Contenedores","text":"<p>Los contenedores son una versi\u00f3n simplificada de las m\u00e1quinas virtuales,  permitiendo la ejecuci\u00f3n de un kernel (sistema operativo) y software adicional (frameworks, bibliotecas, etc ) dentro de un sistema con otro sistema operativo. </p> <p>El uso de contenedores facilita el desarrollar, compartir y poner en marcha el nuevo software minimizando los problemas de dependencias,  actualizaciones etc. </p>"},{"location":"#docker-y-podman","title":"Docker y Podman","text":"<p>Los administradores de contenedores permiten crear y desplegar los contenedores, como asi tambi\u00e9n gestionar, modificar y publicar las im\u00e1genes requeridas para dichos contenedores.</p> <p>El administrador de contenedores m\u00e1s popular es Docker, el cual es de caracter privativo. Una alternativa de c\u00f3digo abierto pensada para una alta compatibilidad con Docker es Podman. Ambas opciones son los usados de referencia para esta documentaci\u00f3n.</p> <p>Comenzar con Docker y Podman</p>"},{"location":"#kubernetes","title":"Kubernetes","text":"<p>Los orquestadores de contenedores son programas que permiten replicar  y controlar m\u00faltiples conjuntos de contenedores iguales de manera autom\u00e1tica, repartiendo el procesamiento entre m\u00faltiples servidores a los que controla.</p> <p>Esto permite:</p> <ul> <li>repartir la carga de trabajo entre m\u00faltiples dispositivos f\u00edsicos;</li> <li>aumentar la confiabilidad de los servicios mediante la redundancia de servidores;</li> <li>gestionar los topes de recursos dedicados en cada servidor: uso de CPU, memoria RAM, etc;</li> <li>reiniciar servicios ca\u00eddos de manera autom\u00e1tica;</li> <li>etc.</li> </ul> <p>El orquestador m\u00e1s popular del momento es Kubernetes, tambni\u00e9n llamado K8s.</p> <p>Comenzar con Kubernetes</p>"},{"location":"tags/","title":"Tags","text":"<p>Todas las etiquetas usadas en la documentaci\u00f3n aparecen aqu\u00ed.</p>"},{"location":"tags/#tag:bash","title":"Bash","text":"<ul> <li>            Variables de Entorno          </li> </ul>"},{"location":"tags/#tag:docker","title":"Docker","text":"<ul> <li>            Argumentos          </li> <li>            Comando run          </li> <li>            Configurar im\u00e1genes          </li> <li>            Contenedores          </li> <li>            Docker Compose          </li> <li>            Editar Im\u00e1genes          </li> <li>            Ejecutar en contenedor          </li> <li>            Escritorio          </li> <li>            Im\u00e1genes Preconstruidas          </li> <li>            Inspeccionar metadatos          </li> <li>            Introducci\u00f3n          </li> <li>            Logs          </li> <li>            Optimizar Im\u00e1genes          </li> <li>            Puertos          </li> <li>            Redes          </li> <li>            Variables de Entorno          </li> <li>            Virtualizaci\u00f3n          </li> <li>            Volumenes          </li> </ul>"},{"location":"tags/#tag:kubernetes","title":"Kubernetes","text":"<ul> <li>            ConfigMap          </li> <li>            DaemonSet          </li> <li>            Deployment          </li> <li>            Ingress          </li> <li>            Introducci\u00f3n          </li> <li>            Kustomization          </li> <li>            Manifiesto          </li> <li>            Secrets          </li> <li>            Servicios          </li> <li>            StatefulSet          </li> </ul>"},{"location":"tags/#tag:mariadb","title":"MariaDB","text":"<ul> <li>            Volumenes          </li> </ul>"},{"location":"tags/#tag:mkdocs","title":"MkDocs","text":"<ul> <li>            Puertos          </li> </ul>"},{"location":"tags/#tag:mongodb","title":"MongoDB","text":"<ul> <li>            Puertos          </li> <li>            Variables de Entorno          </li> </ul>"},{"location":"tags/#tag:podman","title":"Podman","text":"<ul> <li>            Argumentos          </li> <li>            Comando run          </li> <li>            Configurar im\u00e1genes          </li> <li>            Contenedores          </li> <li>            Docker Compose          </li> <li>            Editar Im\u00e1genes          </li> <li>            Ejecutar en contenedor          </li> <li>            Im\u00e1genes Preconstruidas          </li> <li>            Inspeccionar metadatos          </li> <li>            Logs          </li> <li>            Optimizar Im\u00e1genes          </li> <li>            Pods (s\u00f3lo Podman)          </li> <li>            Puertos          </li> <li>            Redes          </li> <li>            Variables de Entorno          </li> <li>            Volumenes          </li> </ul>"},{"location":"tags/#tag:python","title":"Python","text":"<ul> <li>            Configurar im\u00e1genes          </li> </ul>"},{"location":"docker/01_intro/","title":"Docker","text":"<p>Aprende Docker ahora! curso completo gratis desde cero!</p> <p>DOCKER De NOVATO a PRO! (CURSO COMPLETO EN ESPA\u00d1OL)</p> <p>Repositorio de ejemplo</p> <p>Manuales oficiales de Docker</p>","tags":["Docker"]},{"location":"docker/01_intro/#introduccion","title":"Introducci\u00f3n","text":"<p>Docker es un administrador de contenedores de software.  Los contenedores facilitan el desarrollar, compartir y poner en marcha el nuevo software minimizando los problemas de dependencias,  actualizaciones etc.  Los contenedores son una versi\u00f3n simplificada de las m\u00e1quinas virtuales,  permitiendo la ejecuci\u00f3n de un kernel (sistema operativo) y software adicional (frameworks, bibliotecas, etc ) dentro de un sistema con otro sistema operativo. </p>","tags":["Docker"]},{"location":"docker/01_intro/#despliegue-sin-contenedores","title":"Despliegue sin contenedores","text":"<p>Requiere:</p> <ul> <li>c\u00f3digo</li> <li>lista de dependencias </li> <li>archivos de configuraci\u00f3n</li> </ul> <p>Problemas:</p> <ul> <li>Distintas versiones de dependencias</li> <li>m\u00faltiples modos de instalaci\u00f3n</li> <li>m\u00faltiples requisitos de instalaci\u00f3n seg\u00fan sistema operativo</li> <li>Problemas de comunicaci\u00f3n</li> <li>Los problemas se detectan al desplegar \u2192 requerir\u00e1 una vuelta atr\u00e1s (rollback)</li> </ul>","tags":["Docker"]},{"location":"docker/01_intro/#despliegue-con-contenedores","title":"Despliegue con contenedores","text":"<p>El equipo de desarrollo y el de operaciones crean en conjunto una imagen.  La imagen depende del runtime de Docker.  El proceso puede automatizarse con los pipelines  de los servicios de controladores de versi\u00f3n (github, BitBucket, etc).</p>","tags":["Docker"]},{"location":"docker/01_intro/#comandos","title":"Comandos","text":"<p>En esta secci\u00f3n se explora el manejo por comandos  de los recursos disponibles tanto en Docker como en Podman. </p> <p>Ir a la secci\u00f3n de comandos</p>","tags":["Docker"]},{"location":"docker/01_intro/#dockerfile","title":"Dockerfile","text":"<p>Los archivos Dockerfile son indispensables para crear nuevas im\u00e1genes.</p> <p>Ir a la secci\u00f3n de Dockerfile</p>","tags":["Docker"]},{"location":"docker/01_intro/#compose","title":"Compose","text":"<p>Los archivos Compose son la opci\u00f3n preferida para configurar nuevos contenedores tanto individuales como grupales. Apela al comando simplificado <code>compose</code> para la puesta en marcha.</p> <p>Ir a la secci\u00f3n de Compose</p>","tags":["Docker"]},{"location":"docker/02_virtualizacion/","title":"Virtualizaci\u00f3n","text":"","tags":["Docker"]},{"location":"docker/02_virtualizacion/#imagen","title":"Imagen","text":"<p>Es un empaquetado con las dependencias, el c\u00f3digo ,variables de entorno, etc Cada imagen tiene un software distinto: sistema operativo invitado, biblioteca, framework, etc. Distintas versiones del software elegido implican distintas im\u00e1genes. Sin embargo, las im\u00e1genes est\u00e1n divididas internamente en capas (layers), las cuales pueden ser reutilizadas por m\u00faltiples im\u00e1genes.  Esto ayuda a ahorrar espacio en disco evitando el duplicado de capas repetidas. </p>","tags":["Docker"]},{"location":"docker/02_virtualizacion/#contenedor","title":"Contenedor","text":"<p>Es una apilado de im\u00e1genes capaz de ser ejecutado. La capa inferior del contenedor es el kernel elegido. Es muy popular usar Alpine Linux por su peque\u00f1o tama\u00f1o.</p>","tags":["Docker"]},{"location":"docker/02_virtualizacion/#docker-vs-virtual-machines-vm","title":"Docker vs Virtual Machines (VM)","text":"<p>El problema puede pensarse en tres capas</p> <ul> <li>Aplicaciones</li> <li>Kernel</li> <li>Hardware</li> </ul> <p>Las m\u00e1quinas virtuales instalan tanto el kernel como las aplicaciones, demandando muchos GB de espacio y exigiendo esfuerzo computacional extra.</p> <p>Los gestores de contenedores como Docker trabajan compartiendo un kernel para todas las aplicaciones, minimizando el software redundante.</p>","tags":["Docker"]},{"location":"docker/02_virtualizacion/#modos-virtualizacion","title":"Modos virtualizaci\u00f3n:","text":"<ul> <li>Para virtualizaci\u00f3n:  el kernel anfitri\u00f3n (host) da soporte al kernel invitado (guest) de cada m\u00e1quina virtual.  Esta virtualizaci\u00f3n intenta dar tanto  acceso a los kernels invitados al hardware como sea posible.</li> <li>Virtualizacion Parcial:  algunos componentes del hardware se virtualizan para el SO hu\u00e9sped, haciendo que \u00e9ste no pueda acceder a ellos directamente.</li> <li>Virtualizacion Completa:  todos los recursos de hardware son virtualizados, ergo los kernels invitados no tienen acceso directo.</li> </ul> <p>Docker usa el kernel anfitri\u00f3n directamente:</p> <ul> <li>Las im\u00e1genes pesan mucho menos que las m\u00e1quinas virtuales;</li> <li>Los contenedores arrancan casi de inmediato;</li> <li>El rendimiento es mucho mejor.</li> </ul>","tags":["Docker"]},{"location":"docker/03_desktop/","title":"Desktop","text":"","tags":["Docker"]},{"location":"docker/03_desktop/#docker-desktop","title":"Docker Desktop","text":"<p>Es una VM que corre Linux y ejecuta containers  permite acceder al sistema de archivos y a la red , tanto interna como externa Incluye herramientas como Docker Compose, Command Line Interface (CLI), etc. Corre nativo en Windows gracias a WSL2 (Windows Subsystem for Linux)</p>","tags":["Docker"]},{"location":"docker/03_desktop/#comandos","title":"Comandos","text":"<p>Estos comandos se ejecutan en la terminal (recomendado: Bash). Hay que asegurarse primero de que Docker Desktop est\u00e1 no s\u00f3lo inicializado sino tambi\u00e9n corriendo.</p>","tags":["Docker"]},{"location":"docker/comandos/contenedores/","title":"Contenedores","text":"<p>Los contenedores son los objetos que \"rodean\" las im\u00e1genes y que incorporan las configuraciones, rutinas de programa, etc. </p>","tags":["Docker","Podman"]},{"location":"docker/comandos/contenedores/#creacion","title":"Creaci\u00f3n","text":"<p>El comando <code>create</code> (o <code>container create</code>) crea un contenedor nuevo basado en la imagen especificada:</p> DockerPodman Crear contenedor - nombre arbitrario<pre><code>docker create nombre_imagen\ndocker container create nombre_imagen\n</code></pre> Crear contenedor - nombre arbitrario<pre><code>podman create nombre_imagen\ndocker container create nombre_imagen\n</code></pre> <p>Tras la craci\u00f3n se devuelve un n\u00famero de identificador (ID) y adem\u00e1s se asigna un nombre aleatorio al contenedor. </p> <p>Agregando la opci\u00f3n <code>name</code> se crea un contenedor nuevo basado en la imagen especificada con el nombre indicado:</p> DockerPodman Crear contenedor - con nombre<pre><code>docker create --name nombre_contenedor  nombre_imagen\n</code></pre> Crear contenedor - con nombre<pre><code>podman create --name nombre_contenedor nombre_imagen\n</code></pre> <p>Permisos de ejecuci\u00f3n en Podman</p> <p>A diferencia de Docker,  Podman no ejecuta sus contenedores con permisos de administrador.  Como contrapartida, algunas im\u00e1genes requieren que el usuario actual tenga permisos de administrador para ejecutar cada contenedor.  Para quitar esta restricci\u00f3n, a los contenedores se los crea con la opci\u00f3n <code>--security-opt label=disable</code>.</p> <p>De esta forma, la creaci\u00f3n del contenedor queda como:</p> Crear contenedor - con nombre<pre><code>podman create --security-opt label=disable --name nombre_contenedor nombre_imagen\n</code></pre> <p>Otras opciones son el uso de opciones como <code>--privileged</code> y  <code>--security-opt seccomp=unconfined</code>, las cuales ampl\u00edan los alcances y permisos del contenedor en caso que el engine de Podman ya posea permisos de administrador (root).  Estas opciones son menos recomendables en cuanto a la seguridad del sistema se refiere.</p>","tags":["Docker","Podman"]},{"location":"docker/comandos/contenedores/#arranque","title":"Arranque","text":"<p>La puesta en marcha de los contenedores se puede hacer en base a su n\u00famero identificador o en base a su nombre:</p> DockerPodman Arranque - por ID<pre><code>docker start id_contenedor\n</code></pre> Arranque - por nombre<pre><code>docker start nombre_contenedor\n</code></pre> Arranque - por ID<pre><code>podman start id_contenedor\n</code></pre> Arranque - por nombre<pre><code>podman start nombre_contenedor\n</code></pre> <p>Agregando las opciones <code>-a</code> (adjuntar) e <code>-i</code> (interactivo) se puede ver el log en consola y ejecutar comandos:</p> DockerPodman <p>Arranque - interactivo<pre><code>docker start -a -i nombre_contenedor\n</code></pre> Las opciones se pueden indicar juntas:</p> Arranque - interactivo<pre><code>docker start -ai nombre_contenedor      \n</code></pre> <p>Arranque - interactivo<pre><code>podman start -a -i nombre_contenedor\n</code></pre> Las opciones se pueden indicar juntas:</p> Arranque - interactivo<pre><code>podman start -ai nombre_contenedor      \n</code></pre>","tags":["Docker","Podman"]},{"location":"docker/comandos/contenedores/#detencion","title":"Detenci\u00f3n","text":"<p>El comando <code>stop</code> detiene al contenedor indicado:</p> DockerPodman Detenci\u00f3n - por nombre<pre><code>docker stop nombre_contenedor\n</code></pre> Detenci\u00f3n - por nombre<pre><code>podman stop nombre_contenedor\n</code></pre> <p>Se\u00f1ales de parada</p> <p>En Linux la orden <code>stop</code> env\u00eda la se\u00f1al del sistema <code>SIGTERM</code>. Si el contenedor no se detuvo en 10 segundos (valor predeterminado) Podman le env\u00eda la se\u00f1al <code>SIGKILL</code>, lo cual equivale a lanzar la orden <code>kill</code>:</p> Detenci\u00f3n - SIGKILL<pre><code>podman kill nombre_contenedor\n</code></pre> <p>Otras se\u00f1ales</p> <p>Cabe se\u00f1alar que el comando <code>kill</code> permite mandar otras se\u00f1ales diferentes con ayuda de la opci\u00f3n <code>--signal</code>:</p> <p>Se\u00f1ales espec\u00edficas<pre><code>podman kill --signal=\"SIGUP\" nombre_contenedor\n</code></pre> En el ejemplo, la se\u00f1al <code>SIGUP</code> hace que la aplicaci\u00f3n relea sus archivos de configuraci\u00f3n, siempre y cuando la aplicaci\u00f3n lo soporte.</p>","tags":["Docker","Podman"]},{"location":"docker/comandos/contenedores/#listado","title":"Listado","text":"<p>El comando <code>ps</code> indica los contenedores en funcionamiento:</p> DockerPodman Listado - contenedores en funcionamiento<pre><code>docker ps\n</code></pre> Listado - contenedores en funcionamiento<pre><code>podman ps\n</code></pre> <p>Con la opci\u00f3n <code>-a</code> se indican todos los contenedores existentes:</p> DockerPodman Listado - todos los contenedores<pre><code>docker ps -a\n</code></pre> Listado - todos los contenedores<pre><code>podman ps -a\n</code></pre>","tags":["Docker","Podman"]},{"location":"docker/comandos/contenedores/#borrado","title":"Borrado","text":"<p>El comando <code>rm</code> elimina el contenedor indicado:</p> DockerPodman Borrado de contenedor<pre><code>docker rm nombre_contenedor\n</code></pre> Borrado de contenedor<pre><code>podman rm nombre_contenedor\n</code></pre>","tags":["Docker","Podman"]},{"location":"docker/comandos/contenedores/#referencias","title":"Referencias","text":"<p>Red Hat - How to use the <code>--privileged</code> flag with container engines</p> <p>Red Hat - How to use Podman inside of a container</p>","tags":["Docker","Podman"]},{"location":"docker/comandos/exec/","title":"Ejecutar en contenedor","text":"<p>Con el comando <code>exec</code> se puede ingresar un contenedor espec\u00edfico desde la terminal para poder realizar diversas operaciones: instalar nuevas dependencias, leer logs, explorar el interior del contenedor, etc.</p>","tags":["Docker","Podman"]},{"location":"docker/comandos/exec/#comando-unico","title":"Comando \u00fanico","text":"<p>Para ejecutar un comando o aplicaci\u00f3n interno del contenedor se especifica el nombre o el ID del contenedor elegido  y se indica el comando al final: </p> DockerPodman Comando interno<pre><code>docker exec nombre_contenedor nombre_comando ...\ndocker exec     id_contenedor nombre_comando ...\n</code></pre> Comando interno<pre><code>podman exec nombre_contenedor nombre_comando ...\npodman exec     id_contenedor nombre_comando ...\n</code></pre>","tags":["Docker","Podman"]},{"location":"docker/comandos/exec/#modo-interactivo","title":"Modo interactivo","text":"<p>Si se busca ingresar al contenedor para gestionarlo desde la terminal entoces se agrega la opci\u00f3n <code>-it</code> y al final se ordena el comando <code>sh</code> (shell):</p> DockerPodman Shell interna<pre><code>docker exec -it nombre_contenedor sh\ndocker exec -it     id_contenedor sh\n</code></pre> Shell interna<pre><code>podman exec -it nombre_contenedor sh\npodman exec -it     id_contenedor sh\n</code></pre> <p>de esta forma queda abierta la sesi\u00f3n dentro de la terminal actual hasta ingresar el comando <code>exit</code>.</p>","tags":["Docker","Podman"]},{"location":"docker/comandos/imagenes/","title":"Im\u00e1genes Preconstruidas","text":"<p>Las im\u00e1genes son los componentes de software encapsulados, los cuales pueden incorporar int\u00e9rpretes de lenguajes, bibliotecas, frameworks, etc.</p> <p>En este cap\u00edtulo se explican solamente los comandos requeridos para trabajar con im\u00e1genes prefabricadas y disponibles online.</p> <p>DockerHub</p> <p>En DockerHub se puede consultar qu\u00e9 im\u00e1genes hay disponibles e indica el comando completo para descargarlas. </p> <p>Fuentes de im\u00e1genes</p> <ul> <li>DockerHub</li> <li>Fedora Project</li> <li>Red Hat (Es de pago)</li> <li>Quay</li> </ul>","tags":["Docker","Podman"]},{"location":"docker/comandos/imagenes/#listado","title":"Listado","text":"<p>El comando <code>images</code> indica qu\u00e9 im\u00e1genes est\u00e1n descargadas en la PC  y sus caracter\u00edsticas b\u00e1sicas: versi\u00f3n, identificador, espacio ocupado, etc.</p> DockerPodman Listar im\u00e1genes locales<pre><code>docker images\n</code></pre> Listar im\u00e1genes locales<pre><code>podman images\n</code></pre>","tags":["Docker","Podman"]},{"location":"docker/comandos/imagenes/#descarga","title":"Descarga","text":"<p>El comando <code>pull</code> descarga la \u00faltima versi\u00f3n disponible  de la imagen indicada desde DockerHub  y la etiqueta como <code>latest</code>:</p> DockerPodman Descargar imagen - \u00daltima release<pre><code>docker pull nombre_imagen\n</code></pre> Descargar imagen - \u00daltima release<pre><code>podman pull nombre_imagen\n</code></pre> <p>Se puede especificar una versi\u00f3n de la imagen para la descarga a continuaci\u00f3n de su nombre:</p> DockerPodman Descargar imagen - version espec\u00edfica<pre><code>docker pull nombre_imagen:version\n</code></pre> Descargar imagen - version espec\u00edfica<pre><code>podman pull nombre_imagen:numero_version\n</code></pre> <p>Si no se indica la versi\u00f3n se descarga la m\u00e1s reciente (<code>latest</code>). Otras versiones habituales son <code>stable</code>, <code>devel</code>, <code>latest</code>, <code>nightly</code>, etc. La informaci\u00f3n de dichas versiones debe aparecer en la p\u00e1gina de descarga de la imagen elegida.</p> <p>Opciones de imagen</p> <p>Cada imagen puede tener distintas opciones y variables de configuraci\u00f3n,  los cuales habitualmente se indican en la p\u00e1gina  proveedora dede la descarga.</p> <p>Por ello hay que chequear tambi\u00e9n los par\u00e1metros que se requieren para configurar los futuros contenedores basados en estas im\u00e1genes.  </p>","tags":["Docker","Podman"]},{"location":"docker/comandos/imagenes/#borrado","title":"Borrado","text":"<p>Las im\u00e1genes se eliminan del disco con el comando <code>rm</code>:</p> DockerPodman Eliminar imagen local<pre><code>docker image rm nombre_imagen:numero_version\n</code></pre> Eliminar imagen local<pre><code>podman image rm nombre_imagen:numero_version\n</code></pre>","tags":["Docker","Podman"]},{"location":"docker/comandos/inspect/","title":"Inspeccionar metadatos","text":"<p>Los objetos del gestor de contenedor (imagenes, contenedores, redes, volumenes, etc) traen adjuntos los metadatos, que son una colecci\u00f3n de datos informativos sobre dichos objetos: version, nombre, ubicaci\u00f3n en el disco, etc.</p>","tags":["Docker","Podman"]},{"location":"docker/comandos/inspect/#uso-basico","title":"Uso b\u00e1sico","text":"<p>Los metadatos se leen con el comando <code>inspect</code>:</p> DockerPodman inspeccionar<pre><code>docker inspect objeto\n</code></pre> inspeccionar<pre><code>podman inspect objeto\n</code></pre> <p>La metadata se devuelve completa como un objeto JSON, es decir como conjunto de pares clave - valor. Dichas claves pueden venir anidadas: algunas claves pueden ser valores de otras claves.</p>","tags":["Docker","Podman"]},{"location":"docker/comandos/inspect/#distincion-por-tipos","title":"Distinci\u00f3n por tipos","text":"<p>Varios objetos de distinto tipo pueden compartir nombre.  Por ejemplo: un contenedor con un servidor interno puede llamarse <code>server_8000</code> y el mismo contenedor podr\u00eda tener acceso a un volumen llamado <code>server_8000</code>.</p> <p>Para poder diferenciar unos objetos de otros se puede recurr a la opci\u00f3n <code>--type</code>:</p> DockerPodman inspeccionar - por tipo<pre><code>docker inspect --type=container server_8000\ndocker inspect --type=volume    server_8000\n</code></pre> inspeccionar - por tipo<pre><code>podman inspect --type=container server_8000\npodman inspect --type=volume    server_8000\n</code></pre>","tags":["Docker","Podman"]},{"location":"docker/comandos/inspect/#lectura-de-parametros","title":"Lectura de par\u00e1metros","text":"<p>Si se busca solamente un par\u00e1metro particular se usa la opci\u00f3n <code>-f</code> (<code>--format</code> ):</p> DockerPodman inspeccionar - parametro IP<pre><code>docker inspect  -f '{{.NetworkSettings.IPAddress}}' nombre_contenedor\ndocker inspect  --format='{{.NetworkSettings.IPAddress}}' nombre_contenedor\n</code></pre> inspeccionar - parametro IP<pre><code>podman inspect  -f '{{.NetworkSettings.IPAddress}}' nombre_contenedor\npodman inspect  --format='{{.NetworkSettings.IPAddress}}' nombre_contenedor\n</code></pre> <p>En este ejemplo se consulta la clave <code>NetworkSettings</code> y entre sus valores se busca la clave <code>IPAddress</code>. </p>","tags":["Docker","Podman"]},{"location":"docker/comandos/inspect/#tamano","title":"Tama\u00f1o","text":"<p>En el caso espec\u00edfico de los contenedores se puede agregar la opci\u00f3n <code>--size</code>:</p> DockerPodman inspeccionar - dimensiones agregadas<pre><code>docker inspect --size nombre_contenedor\n</code></pre> inspeccionar - dimensiones agregadas<pre><code>podman inspect --size nombre_contenedor\n</code></pre> <p>Esta opci\u00f3n agrega dos nuevos campos de datos:</p> <ul> <li><code>SizeRootFs</code>: espacio total (en bytes) del contenedor</li> <li><code>SizeRw</code> : espacio de los archivos creados o modificados del contenedor. </li> </ul> DockerPodman inspeccionar - espacio total<pre><code>docker inspect --size nombre_contenedor -f '{{ .SizeRootFs }}'\n</code></pre> inspeccionar - espacio de cambios<pre><code>docker inspect --size nombre_contenedor -f '{{ .SizeRw }}'  \n</code></pre> inspeccionar - espacio total<pre><code>podman inspect --size nombre_contenedor -f '{{ .SizeRootFs }}'\n</code></pre> inspeccionar - espacio de cambios<pre><code>podman inspect --size nombre_contenedor -f '{{ .SizeRw }}'  \n</code></pre>","tags":["Docker","Podman"]},{"location":"docker/comandos/inspect/#referencias","title":"Referencias","text":"<p>Docker Docs - docker inspect</p>","tags":["Docker","Podman"]},{"location":"docker/comandos/logs/","title":"Logs","text":"<p>El comando <code>logs</code> da los reportes del container usado hasta el presente y devuelve el control de la terminal al usuario:</p> DockerPodman mensajes de log<pre><code>docker logs nombre_contenedor\n</code></pre> mensajes de log<pre><code>podman logs nombre_contenedor\n</code></pre> <p>Agregando la opci\u00f3n <code>--follow</code> la terminal queda en espera a nuevos eventos:</p> DockerPodman mensajes de log - modo live<pre><code>docker logs --follow nombre_contenedor\n</code></pre> mensajes de log - modo live<pre><code>podman logs --follow nombre_contenedor\n</code></pre> <p>Atajo de salida</p> <p>Se sale del modo live con Ctrl + C</p>","tags":["Docker","Podman"]},{"location":"docker/comandos/puertos/","title":"Puertos","text":"","tags":["MkDocs","Docker","Podman","MongoDB"]},{"location":"docker/comandos/puertos/#introduccion","title":"Introducci\u00f3n","text":"<p>Los contenedores se comunican con el resto del software mediante el protocolo TCP/IP, implementando sockets (\"z\u00f3calos\").</p> <p>Los sockets se componen por una direcci\u00f3n IP y por un n\u00famero de puerto.  Cada imagen tiene un n\u00famero de puerto preasignado,  el cual es heredado del software interno  y cuyo contenedor hereda tambi\u00e9n de manera predeterminada. Por este motivo varios contenedores activos pueden heredar un mismo n\u00famero de puerto,  por ejemplo si se manejan im\u00e1genes de un mismo framework en distintas versiones  o si se trata de una misma imagen siendo usada para varios programas distintos. </p>","tags":["MkDocs","Docker","Podman","MongoDB"]},{"location":"docker/comandos/puertos/#port-mapping","title":"Port Mapping","text":"<p>Dos o m\u00e1s im\u00e1genes activas pueden tener un mismo n\u00famero de puerto huesped, en tanto que dos contenedores activos  no pueden tener un mismo n\u00famero de puerto para comunicarse con el host.  El port mapping o mapeo de puertos consiste en asignar n\u00fameros de puerto a cada contenedor para prevenir conflictos entre ellos.</p>","tags":["MkDocs","Docker","Podman","MongoDB"]},{"location":"docker/comandos/puertos/#sintaxis","title":"Sintaxis","text":"<p>El mapeo se implementa con la opci\u00f3n <code>-p</code> (publish) y consta de:</p> <ul> <li>El n\u00famero de puertos para el anfitri\u00f3n;</li> <li>El n\u00famero de puerto de la imagen. </li> </ul> <p>La sintaxis es la siguiente:</p> DockerPodman Contenedor - con port mapping<pre><code>docker create -p puerto_anfitrion:puerto_imagen --name nombre_contenedor  nombre_imagen\n</code></pre> Contenedor - con port mapping<pre><code>podman create -p puerto_anfitrion:puerto_imagen --name nombre_contenedor nombre_imagen\n</code></pre> <p>Importante: no poner espacios entre n\u00fameros de puerto y signo <code>:</code>.</p> <p>Material for MkDocs</p> <p>Este framework que renderiza documentos en formato Markdown implementa su live server (servidor para pruebas) locales el puerto 8000.  Por ello, los contenedores creados para implementar dicho server deben mapear al puerto <code>8000</code>:</p> DockerPodman mkdocs-material - live server<pre><code>docker pull mkdocs-material    \ncd ruta_proyecto\ndocker create --name live_server -p puerto_host:8000 -v ${PWD}:/docs mkdocs-material\n</code></pre> mkdocs-material - live server<pre><code>podman pull mkdocs-material   \ncd ruta_proyecto\npodman create --name live_server -p puerto_host:8000 --security-opt label=disable -v ${PWD}:/docs mkdocs-material\n</code></pre> <p>Aclaraci\u00f3n: la opci\u00f3n adicional <code>-v ${PWD}:/docs</code> tiene que ver con el uso de volumenes. Es la ruta relativa a los documentos internos del proyecto actual.</p> <p>N\u00ba de puerto \u00fanico</p> <p>Si se indica un solo n\u00famero de puerto  entonces la m\u00e1quina de contenedores asumir\u00e1 que \u00e9ste es puerto de la imagen y entonces elegir\u00e1 el puerto de host arbitrarimente.</p> <p>Por ejemplo, MongoDB usa el puerto <code>27017</code>.  Al indicar dicho numero durante la creaci\u00f3n del container y al no especificar el puerto de host el engine asigna un puerto de host arbitrario como el <code>46665</code> o el<code>52043</code>: </p> DockerPodman <pre><code>docker create  -p27017 --name mong_p1    mongo\n</code></pre> <pre><code>podman create  -p27017 --name mong_p1    mongo\n</code></pre> <p>En general es mejor especificar ambos puertos al crear contenedores con port-mapping.</p>","tags":["MkDocs","Docker","Podman","MongoDB"]},{"location":"docker/comandos/redes/","title":"Redes","text":"<p>Cuando hay que conectar varios contenedores interdependientes conviene usar las redes (networks).  Estas son alternativas al port mapping que no necesitan configuraci\u00f3n de puertos para funcionar.</p>","tags":["Docker","Podman"]},{"location":"docker/comandos/redes/#administrar-redes","title":"Administrar redes","text":"","tags":["Docker","Podman"]},{"location":"docker/comandos/redes/#listar-redes","title":"Listar redes","text":"<p>Enumera las redes ya existentes:</p> DockerPodman Redes - listar<pre><code>docker network ls\n</code></pre> Redes - listar<pre><code>podman network ls\n</code></pre>","tags":["Docker","Podman"]},{"location":"docker/comandos/redes/#crear-red","title":"Crear red","text":"<p>Crea una nueva red del tipo bridge (puente) con el nombre especificado:</p> DockerPodman Redes - crear<pre><code>docker network create nombre_red\n</code></pre> Redes - crear<pre><code>podman network create nombre_red\n</code></pre>","tags":["Docker","Podman"]},{"location":"docker/comandos/redes/#eliminar-red","title":"Eliminar red","text":"<p>Elimina la red indicada:</p> DockerPodman Redes - eliminar<pre><code>docker network rm nombre_red\n</code></pre> Redes - eliminar<pre><code>podman network rm nombre_red\n</code></pre>","tags":["Docker","Podman"]},{"location":"docker/comandos/redes/#contenedores-conectados","title":"Contenedores conectados","text":"<p>Al crear un contenedor nuevo se pueden incluir las opciones:</p> <ul> <li><code>--network</code> :   especifica el nombre de red preexistente a conectar;</li> <li><code>--network-alias</code>: funciona como un apuntador de la red al contenedor destino de la red (opcional).</li> </ul>","tags":["Docker","Podman"]},{"location":"docker/comandos/redes/#sintaxis","title":"Sintaxis","text":"<p>La red puente se agrega como una opci\u00f3n m\u00e1s:</p> DockerPodman Contenedores - conectados a red<pre><code>docker create   --network nombre_red  --name nombre_contenedor  nombre_imagen\n</code></pre> Contenedores - conectados a red<pre><code>podman create   --network nombre_red   --name nombre_contenedor  nombre_imagen\n</code></pre> <p>Redes preexistentes</p> <p>Para que la comunicaci\u00f3n entre contenedores funcione es necesario que las redes que estos utilizan hayan sido creadas previamente.</p>","tags":["Docker","Podman"]},{"location":"docker/comandos/redes/#inspeccion","title":"Inspecci\u00f3n","text":"<p>Las redes se inspeccionan con el comando <code>dig</code>:</p> Inspecci\u00f3n de redes<pre><code>dig nombre-red\ndig  alias-red\n</code></pre> <p>El resultado es un informe de las direcciones IP, puertos,tipo de socket, etc. que usan los contenedores.</p> <p>DNS en networks</p> <p>Las networks que usan los gestores de contenedores hacen uso de su propio servicio DNS (Name Domain Server) interno  para completar las conexiones entre los contenedores. Por eso no se especifican IPs ni puertos al incluirlas.</p>","tags":["Docker","Podman"]},{"location":"docker/comandos/redes/#referencias","title":"Referencias","text":"<p>Repositorio ofical de Podman - Networking b\u00e1sico</p> <p>Docker Docs - Bridge network driver</p>","tags":["Docker","Podman"]},{"location":"docker/comandos/run/","title":"Comando <code>run</code>","text":"<p>Este comando combina varias acciones:</p> <ul> <li>Busca la imagen y si no est\u00e1 disponible localmente la descarga autom\u00e1ticamente (<code>pull</code>);</li> <li>Crea un contenedor que incluye la imagen elegida (<code>create</code>);</li> <li>Inicia el contenedor creado (<code>start</code>).</li> </ul> <p><code>run</code> funciona como una variante simplificada de <code>create</code>  y por ello acepta todas sus opciones de configuraci\u00f3n.</p>","tags":["Docker","Podman"]},{"location":"docker/comandos/run/#uso","title":"Uso","text":"<p>Uso b\u00e1sico:</p> DockerPodman comando run<pre><code>docker run nombre_imagen\n</code></pre> comando run<pre><code>podman run nombre_imagen\n</code></pre> <p>Esta instrucci\u00f3n no devuelve el control al usuario a menos que termine  \u00f3 se presione Ctrl+C (cancelaci\u00f3n).  Si se repite el comando varias veces se crean varios contenedores parecidos, uno por comando.</p>","tags":["Docker","Podman"]},{"location":"docker/comandos/run/#segundo-plano","title":"Segundo plano","text":"<p>La opci\u00f3n <code>-d</code> (detached) devuelve el control al usuario de inmediato:</p> DockerPodman comando run - segundo plano<pre><code>docker run  -d nombre_imagen\n</code></pre> comando run - segundo plano<pre><code>podman run -d nombre_imagen\n</code></pre> <p>de esta forma el contenedor seguir\u00e1 funcionando en segundo plano.</p> <p>Lo mismo pero a\u00f1adiendo el port mapping:</p> DockerPodman comando run - port mapping<pre><code>docker run --name nombre_contenedor -p puerto_anfitrion:puerto_imagen -d nombre_imagen\n</code></pre> comando run - port mapping<pre><code>podman run --name nombre_contenedor -p puerto_anfitrion:puerto_imagen -d nombre_imagen\n</code></pre>","tags":["Docker","Podman"]},{"location":"docker/comandos/run/#contenedores-descartables","title":"Contenedores descartables","text":"<p>La opci\u00f3n <code>--rm</code> permite crear contenedores descartables.  \u00c9stos son eliminados autom\u00e1ticamente cuando se detienen. </p> DockerPodman comando run - contenedores descartables<pre><code>docker run --rm nombre_imagen\n</code></pre> comand run - contenedores descartables<pre><code>podman run --rm nombre_imagen\n</code></pre> <p>Ejemplo de uso: Banner de Podman</p> DockerPodman Contenedor de Banner<pre><code>docker run -dt --name PodmanBanner --replace  -p 8081:80 quay.io/libpod/banner\n</code></pre> Contenedor de Banner<pre><code>podman run -dt --name PodmanBanner --replace  -p 8081:80 quay.io/libpod/banner\n</code></pre> Request al contenedor<pre><code>curl localhost:8081\n</code></pre> <p>Logo respuesta:</p> <pre><code>   ___          __                 \n  / _ \\___  ___/ /_ _  ___ ____    \n / ___/ _ \\/ _  /  ' \\/ _ `/ _ \\    \n/_/   \\___/\\_,_/_/_/_/\\_,_/_//_/   \n</code></pre>","tags":["Docker","Podman"]},{"location":"docker/comandos/variables_entorno/","title":"Variables de Entorno","text":"<p>Las variables de entorno del contenedor se agregan al contenedor durante su creaci\u00f3n, mediante la opci\u00f3n <code>-e</code>. </p>","tags":["Docker","Podman","Bash","MongoDB"]},{"location":"docker/comandos/variables_entorno/#valores-fijos","title":"Valores fijos","text":"<p>La primera opci\u00f3n es asignar los valores a las variables de entorno durante la orden de creaci\u00f3n del contenedor:</p> DockerPodman Crear contenedor - con variable entorno<pre><code>docker create -e VARIABLE=valor  nombre_imagen\n</code></pre> Crear contenedor - con variable entorno<pre><code>podman create -e VARIABLE=valor  nombre_imagen\n</code></pre> <p>De usarse varias variables de entorno se usa la opci\u00f3n <code>-e</code> para separlas:</p> DockerPodman Crear contenedor - con varias variables entorno<pre><code>docker create -e VARIABLE_1=valor_1 -e VARIABLE_2=valor_2 nombre_imagen\n</code></pre> Crear contenedor - con varias variables entorno<pre><code>podman create -e VARIABLE_1=valor_1 -e VARIABLE_2=valor_2 nombre_imagen\n</code></pre> <p>Las variables de entorno requeridas por cada imagen se indican en la p\u00e1gina proveedora de la descarga. </p> <p>M\u00faltiples lineas de la teminal</p> <p>Para repartir las instrucciones de la terminal en varios renglones caa una se recurre al uso de barras invertidas (<code>\\</code>).</p> DockerPodman Crear contenedor - con varias variables entorno<pre><code>docker create \\\n-e VARIABLE_1=valor_1 \\\n-e VARIABLE_2=valor_2 \\ \nnombre_imagen\n</code></pre> Crear contenedor - con varias variables entorno<pre><code>podman create \\\n-e VARIABLE_1=valor_1 \\\n-e VARIABLE_2=valor_2 \\ \nnombre_imagen\n</code></pre> <p>Ejemplo: MongoDB con usuario y contrase\u00f1a</p> <p>En el ejemplo se hace un contenedor de MongoDB (base de datos no relacional)  al que se le asigna nombre de usuario y contrase\u00f1a internos para su consulta:</p> DockerPodman MongoDB - con usuario y contrase\u00f1a<pre><code>docker create  \\\n-e MONGO_INITDB_ROOT_USERNAME=mongoadmin \\\n-e MONGO_INITDB_ROOT_PASSWORD=secret \\\n--name mongo_admin  mongo \n</code></pre> MongoDB - con usuario y contrase\u00f1a<pre><code>podman create  \\\n-e MONGO_INITDB_ROOT_USERNAME=mongoadmin \\\n-e MONGO_INITDB_ROOT_PASSWORD=secret \\\n--name mongo_admin  mongo \n</code></pre>","tags":["Docker","Podman","Bash","MongoDB"]},{"location":"docker/comandos/variables_entorno/#variables","title":"Variables","text":"<p>Los valores necesarios se pueden pasar creando variables desde la terminal, antes de crear el contenedor.</p> Variables - crear<pre><code># creacion \nVARIABLE=valor\n</code></pre> <p>entonces el valor se asigna anteponiendo el s\u00edmbolo <code>$</code>a cada variable:</p> DockerPodman Crear contenedor - con variable<pre><code>docker create -e VARIABLE=$VARIABLE  nombre_imagen\n</code></pre> Crear contenedor - con variable<pre><code>podman create -e VARIABLE=$VARIABLE  nombre_imagen\n</code></pre> <p>El valor de las variables se verifica con el comando <code>echo</code></p> Variables - consultar<pre><code># consulta\necho $VARIABLE\necho ${VARIABLE}\n</code></pre>","tags":["Docker","Podman","Bash","MongoDB"]},{"location":"docker/comandos/variables_entorno/#variables-de-entorno_1","title":"Variables de entorno","text":"<p>Con el uso de variables de entorno se evita el tener que asignar valor a cada variable del contenedor.</p> <p>Para crear las variables de entorno en Bash se usa el comando <code>export</code>:</p> Variables de entorno - crear<pre><code># creacion\nexport VARIABLE_1=valor_1\nexport VARIABLE_2=valor_2\n</code></pre> <p>y al crear el contenedor ya no es necesario hacer la asignaci\u00f3n, sino que con enumerar las variables alcanza:</p> DockerPodman Crear contenedor - con variables de entorno<pre><code>docker create -e VARIABLE_1 -e VARIABLE_2  nombre_imagen\n</code></pre> Crear contenedor - con variables de entorno<pre><code>podman create -e VARIABLE_1 -e VARIABLE_2  nombre_imagen\n</code></pre> <p>Comando <code>history</code></p> <p>El comando <code>history</code> permite conocer el historial de comandos previos de Bash. Por este motivo hay que evitar asignar los valores de variables sensibles (por ejemplo: contrase\u00f1as) desde la terminal.</p>","tags":["Docker","Podman","Bash","MongoDB"]},{"location":"docker/comandos/variables_entorno/#archivos-de-entorno","title":"Archivos de entorno","text":"<p>Las variables de entorno que necesita el contenedor se pueden guardar en forma de archivo de texto con la extensi\u00f3n <code>.env</code>:</p> Archivos .env - formato<pre><code>VARIABLE_1=valor_1 \nVARIABLE_2=valor_2 \n</code></pre> <p>Cada l\u00ednea de este archivo representa una variable de entorno.</p> <p>Gracias a la opci\u00f3n <code>--env-file</code> las variables de entorno se pueden adjuntar todas juntas indicando el nombre de archivo:</p> DockerPodman Crear contenedor - con variable entorno<pre><code>docker create --env-file variables.env  nombre_imagen\n</code></pre> Crear contenedor - con variable entorno<pre><code>podman create --env-file variables.env  nombre_imagen\n</code></pre> <p>Archivos <code>.env</code></p> <p>El archivo con las variables de entorno suele ser llamado simplemente <code>.env</code>.</p>","tags":["Docker","Podman","Bash","MongoDB"]},{"location":"docker/comandos/variables_entorno/#referencias","title":"Referencias","text":"<p>Docker Docs - Set environment variables within your container's environment</p>","tags":["Docker","Podman","Bash","MongoDB"]},{"location":"docker/comandos/volumes/","title":"Volumenes","text":"<p>Los vol\u00famenes o volumes son directorios del sistema anfitri\u00f3n a los cuales los contenedores pueden acceder para leer o escribir archivos de datos.  Estos datos pueden ser registros del funcionamiento del contenedor, bases de datos creadas en la ejecuci\u00f3n, rutinas de lenguajes interpretados por el contenedor que se requiere poder actualizar desde fuera, etc. El uso de vol\u00famenes permite mantener los datos afuera del contenedor, previniendo su borrado cuando se eliminan los contenedores. </p>","tags":["Docker","Podman","MariaDB"]},{"location":"docker/comandos/volumes/#tipos-de-volumenes","title":"Tipos de vol\u00famenes","text":"<p>Hay varios tipos de volumenes en base a su creaci\u00f3n:</p> <ul> <li>An\u00f3nimos: en \u00e9stos solo se indica la ruta de origen a montar. No son referenciables desde otros contenedores.  El gestor de contenedores elige la ubicaci\u00f3n autom\u00e1ticamente. </li> <li>Nombrados: son similares a los vol\u00famenes an\u00f3nimos pero pueden ser referenciados por m\u00faltiples contenedores gracias a su nombre,  permitiendo su compartimento y reutilizaci\u00f3n.</li> <li>De anfitri\u00f3n o host: en estos vol\u00famenes se indica qu\u00e9 carpeta montar y ad\u00f3nde montarla.</li> </ul>","tags":["Docker","Podman","MariaDB"]},{"location":"docker/comandos/volumes/#gestionar-volumenes","title":"Gestionar volumenes","text":"","tags":["Docker","Podman","MariaDB"]},{"location":"docker/comandos/volumes/#crear","title":"Crear","text":"DockerPodman Volumen - crear<pre><code>docker volume create nombre_volumen\n</code></pre> Volumen - crear<pre><code>podman volume create nombre_volumen\n</code></pre>","tags":["Docker","Podman","MariaDB"]},{"location":"docker/comandos/volumes/#listar","title":"Listar","text":"<p>La lista de los vol\u00famenes de usuario se obtiene con el comando <code>list</code>:</p> DockerPodman Listado de volumenes<pre><code>docker volume list\n</code></pre> Listado de volumenes<pre><code>podman volume list\n</code></pre>","tags":["Docker","Podman","MariaDB"]},{"location":"docker/comandos/volumes/#inspeccionar","title":"Inspeccionar","text":"<p>La informaci\u00f3n del volumen elegido se obtiene con el comando <code>inspect</code>:</p> DockerPodman Volumen - inspeccionar<pre><code>docker volume inspect nombre_volumen \n</code></pre> Volumen - inspeccionar<pre><code>podman volume inspect nombre_volumen \n</code></pre> <p>El punto de montaje es la ruta donde el volumen almacenar\u00e1 los datos. \u00c9ste se consulta con la opci\u00f3n <code>--format {{.Mountpoint}}</code> :</p> DockerPodman Volumen - punto de montaje<pre><code>docker volume inspect nombre_volumen --format {{.Mountpoint}}\n</code></pre> Volumen - punto de montaje<pre><code>podman volume inspect nombre_volumen --format {{.Mountpoint}}\n</code></pre> <p>En el ejemplo, el punto de montaje queda: <code>/home/USUARIO/.local/share/containers/storage/volumes/nombre_volumen/_data</code></p> <p>Volumenes en Linux</p> <p>En sistemas Linux, la ruta habitual de almacenamiento de los vol\u00famenes es:</p> <p><code>/home/USUARIO/.local/share/containers/storage/volumes/</code></p> <p>M\u00e1s informaci\u00f3n sobre el comando inspect.</p>","tags":["Docker","Podman","MariaDB"]},{"location":"docker/comandos/volumes/#borrar-voluemn","title":"Borrar voluemn","text":"<p>Los volumenes se pueden eliminar uno a uno con ayuda del comando <code>rm</code>: </p> DockerPodman Borrar volumen<pre><code>docker volume rm nombre_volumen\n</code></pre> Borrar volumen<pre><code>podman volume rm nombre_volumen\n</code></pre> <p>Volumenes del sistema en Linux</p> <p>Los vol\u00famenes del sistema son invisibles para el usuario a menos que se recurra a la orden <code>sudo</code> para ejecutar los comandos:</p> volumenes del sistema<pre><code>sudo podman volume create nombre_volumen    # crear\nsudo podman volume inspect nombre_volumen   # inspeccionar\nsudo podman volume list                     # listar\nsudo podman volume rm  nombre_volumen       # borrar\n</code></pre> <p>Los volumenes del sistema en Linux se guardan en la ruta: <code>/var/lib/containers/storage/volumes/</code></p>","tags":["Docker","Podman","MariaDB"]},{"location":"docker/comandos/volumes/#borrar-no-utilizados","title":"Borrar (no utilizados)","text":"<p>Con el comando <code>prune</code> se puede eliminar aquellos contenedores que no est\u00e1n siendo usados por ningun contenedor: </p> DockerPodman Borrar volumenes no usados<pre><code>docker volume prune\n</code></pre> Borrar volumenes no usados<pre><code>podman volume prune\n</code></pre> <p>Este comando lista los volumenes susceptibles de ser borrados y pide confirmaci\u00f3n antes de eliminarlos.</p>","tags":["Docker","Podman","MariaDB"]},{"location":"docker/comandos/volumes/#crear-contenedores-con-volumenes","title":"Crear contenedores con volumenes","text":"<p>La forma de configurar el agregado de volumenes es mediante la opci\u00f3n <code>-v</code>.  Con ella se especifican:</p> <ul> <li>el nombre del volumen  o la ruta del directorio del anfitri\u00f3n;</li> <li>la ruta interna del contenedor sobre la que se debe montar el volumen.</li> </ul> <p>Se permite la asignaci\u00f3n de m\u00faltiples volumenes al mismo contenedor usando repetidas veces la opc\u00ed\u00f3n <code>-v</code>.</p>","tags":["Docker","Podman","MariaDB"]},{"location":"docker/comandos/volumes/#volumenes-con-nombre","title":"Volumenes con nombre","text":"<p>El nuevo contenedor puede acceder a un volumen preexistente en base a su nombre:</p> DockerPodman montaje de volumen - solo lectura<pre><code>docker create -v nombre_volumen:ruta_montaje_interna  nombre_imagen\n</code></pre> montaje de volumen - solo lectura<pre><code>podman create -v nombre_volumen:ruta_montaje_interna  nombre_imagen\n</code></pre>","tags":["Docker","Podman","MariaDB"]},{"location":"docker/comandos/volumes/#ruta-de-host","title":"Ruta de host","text":"<p>Otra manera de implementar el volumen es indicando directamente la ruta del sistema anfitri\u00f3n al que el contenedor tendr\u00e1 acceso: </p> DockerPodman montaje de volumen - solo lectura<pre><code>docker create -v ruta_host:ruta_montaje_interna  nombre_imagen\n</code></pre> montaje de volumen - solo lectura<pre><code>podman create -v ruta_host:ruta_montaje_interna  nombre_imagen\n</code></pre>","tags":["Docker","Podman","MariaDB"]},{"location":"docker/comandos/volumes/#solo-lectura","title":"S\u00f3lo lectura","text":"<p>Los volumenes se pueden agregar a los contenedores con la opci\u00f3n <code>ro</code> (read only)</p> montaje de volumen - solo lectura<pre><code>podman create -v nombre_volumen:ruta_montaje_interna:ro  nombre_imagen\n</code></pre>","tags":["Docker","Podman","MariaDB"]},{"location":"docker/comandos/volumes/#ejemplo-aplicado-base-de-datos","title":"Ejemplo aplicado: base de datos","text":"<p>En este ejemplo se crea una base de datos SQL con la imagen oficial de MariaDB. Se agregan las siguientes configuraciones:</p> <ul> <li>la conexion se mantiene en el puerto <code>3306</code> (predefinido);</li> <li>acceso con usuario <code>root</code> (administrador) y contrase\u00f1a <code>1234</code>;</li> <li>una base de datos vac\u00eda llamada <code>mi-db</code>;</li> <li>un volumen pesistente para la base de datos interna. </li> </ul> <p>Primero se exportan los valores de las variables de entorno:</p> variables de entorno<pre><code># variables de entorno\nexport MARIADB_ROOT_PASSWORD=1234\nexport MARIADB_DATABASE=mi-db\n</code></pre> <p>Luego se crea un volumen nombrado <code>mariadb-persistente</code>:</p> DockerPodman volumen<pre><code># creacion volmen\ndocker volume create mariadb-persistente\n</code></pre> volumen<pre><code># creacion volmen\npodman volume create mariadb-persistente \n</code></pre> <p>Y por \u00faltimo se crea el contenedor, con el nombre <code>mariadb-test</code>:</p> DockerPodman contenedor con volumen<pre><code>docker create --name mariadb-test -p3306:3306 \\\n-e MARIADB_DATABASE \\\n-e MARIADB_ROOT_PASSWORD \\\n-v mariadb-persistente:/var/lib/mysql \\\n--replace  mariadb:latest  \n</code></pre> contenedor con volumen<pre><code>podman create --name mariadb-test -p3306:3306 \\\n-e MARIADB_DATABASE \\\n-e MARIADB_ROOT_PASSWORD \\\n-v mariadb-persistente:/var/lib/mysql \\\n--replace  mariadb:latest  \n</code></pre> <p>Para poder verificar que el contenedor est\u00e1 bien configurado s\u00f3lo hay que cargar los datos en un conector o programa front compatible con bases MariaDB y verificar que la conexi\u00f3n es exitosa. Y para corroborar la persistencia de datos hay que:</p> <ul> <li>crear cambios (tablas, otras bases de datos, etc);</li> <li>borrar el contenedor</li> <li>crear el contenedor de nuevo.</li> </ul> <p>Los datos agregados o modificados deben seguir all\u00ed.</p> <p>TIP: rutas para bases de datos</p> <p>Los gestores de bases de datos tienen ciertas rutas predefinidas para guardar la informaci\u00f3n.  En los sistemas Linux estas rutas son:</p> Base de datos ruta de montaje MySQL / MariaDB <code>/var/lib/mysql</code> PostgreSQL <code>/var/lib/postgresql/data</code> MongodB <code>/data/db</code> <p>Dado que las im\u00e1genes de Docker y Podman son basadas en distribuciones Linux, estas mismas rutas son las usadas adentro del contenedor.</p> <p>Rutinas en volumenes</p> <p>Una posibilidad que permiten los volumenes es pasar las rutinas a ejecutar por adentro de ellos.  Esto evita tener que reconstruir los containers cada vez que se hagan cambios en las rutinas.</p>","tags":["Docker","Podman","MariaDB"]},{"location":"docker/comandos/volumes/#referencias","title":"Referencias","text":"<p>RedHat.com - Compartiendo archivos entre dos contenedores</p> <p>Docker Docs - Volumes</p>","tags":["Docker","Podman","MariaDB"]},{"location":"docker/compose/compose/","title":"Compose","text":"","tags":["Docker","Podman"]},{"location":"docker/compose/compose/#introduccion","title":"Introducci\u00f3n","text":"<p>El comando Compose habilita usar una plantilla para facilitar  la creaci\u00f3n de los contenedores y su interconexi\u00f3n. </p> <p>El comando <code>docker compose</code> viene integrado por defecto en Docker; en cambio Podman no lo trae incorporado sino que debe ser instalado y habilitado como extensi\u00f3n  y se puede invocar tanto por <code>docker-compose</code> como por <code>podman compose</code> </p> <p>El comando presupone la existencia de un archivo de configuraci\u00f3n,  tal como se explica a continuaci\u00f3n.</p>","tags":["Docker","Podman"]},{"location":"docker/compose/compose/#archivos-compose","title":"Archivos Compose","text":"<p>El archivo de configuraci\u00f3n t\u00edpico se llama <code>docker-compose.yml</code>.  </p> <p>Dentro del archivo debe respetarse estrictamente la indentaci\u00f3n sino no funciona. Tambi\u00e9n hay que respetar las comillas para los n\u00fameros de puerto y los guiones donde se indican.  Los comentarios son precedidos del car\u00e1cter <code>#</code>. En caso de indicarse, Docker Compose aprovecha el archivo Dockerfile por defecto para completar la configuraci\u00f3n del proyecto.</p>","tags":["Docker","Podman"]},{"location":"docker/compose/compose/#sintaxis-basica","title":"Sintaxis b\u00e1sica","text":"<p>Sintaxis (ejemplo): <pre><code>version:  \u201cnumero_version\u201d\n\nservices:\n\n    contenedor_1:\n        build:  ruta_Dockerfile \n        ports:\n            # lista de mapeos\n            - \u201cpuerto_host_1:puerto_imagen_1\u201d\n            - \u201cpuerto_host_2:puerto_imagen_2\u201d \n            # (respetar las comillas dobles para los puertos)\n\n        links:\n             - contenedor_2     # contenedor destino\n\n    contenedor_2:\n        image: imagen_2     # (Imagen preexistente)\n        ports: \n            - \"puerto_host_n:puerto_imagen_n\"\n        environment:\n            - VARIABLE_ENTORNO_1=valor_1\n            - VARIABLE_ENTORNO_2=valor_2\n        volumes:\n            # lista de volumenes accesibles \n            - nombre_volumen: ruta_montaje_interna \n\nvolumes:\n    # nombre para el volumen \n    nombre_volumen: \n</code></pre></p> <p>version</p> <p>La etiqueta <code>version</code> est\u00e1 obsoleta y es ignorada.</p> <p><code>link</code> vs <code>depends_on</code></p> <p>La opci\u00f3n <code>link</code>, usada para comunicar un servicio/contenedor con otro, est\u00e1 obsoleta y el Compose de Podman ya no la ejecuta arrojando un error. Su reemplazo es la opci\u00f3n <code>depends_on</code>.</p> <pre><code>links:\n    - contenedor_2      #contenedor destino\n</code></pre> <pre><code>depends_on:\n    - contenedor_2      #contenedor destino\n</code></pre> <p>M\u00e1s info: Stack Overflow - Difference between links and depends_on in docker_compose.yml</p>","tags":["Docker","Podman"]},{"location":"docker/compose/compose/#ejecucion","title":"Ejecuci\u00f3n","text":"","tags":["Docker","Podman"]},{"location":"docker/compose/compose/#creacion-automatica","title":"Creaci\u00f3n autom\u00e1tica","text":"<p>Crea los contenedores deseados y las im\u00e1genes necesarias en base al archivo <code>docker-compose.yml</code>.  <pre><code>docker compose up\ndocker-compose up       # versiones antiguas de Docker\n</code></pre></p> <p>Tambi\u00e9n crea las redes necesarias por defecto. Una vez terminado los hace funcionar.  Puede interrumpirse haciendo  Ctrl+C .</p>","tags":["Docker","Podman"]},{"location":"docker/compose/compose/#eliminacion-automatica","title":"Eliminaci\u00f3n autom\u00e1tica","text":"<p>Eliminar los contenedores dise\u00f1ados con el archivo <code>docker-compose.yml</code>: <pre><code>docker compose down\ndocker-compose down     # versiones antiguas de Docker\n</code></pre> Tambi\u00e9n elimina las redes comunes entre contenedores.</p>","tags":["Docker","Podman"]},{"location":"docker/compose/compose/#rama-desarrollo","title":"Rama desarrollo","text":"<p>Es posible crear dos archivos alternos de configuraci\u00f3n para crear una rama de desarrollo (development) de los contenedores sin afectar la rama que ya est\u00e1 operando. </p>","tags":["Docker","Podman"]},{"location":"docker/compose/compose/#sintaxis","title":"Sintaxis","text":"<p>Para esto se crean dos archivos adicionales llamados <code>Dockerfile.dev</code> y <code>docker-compose-dev.yml</code>. Este segundo archivo debe apuntar al primero, esto se hace a\u00f1adiendo las siguientes lineas: <pre><code>#(dentro del archivo docker-compose-dev.yml)\nversion:  \u201cnumero_version\u201d\nservices:\n    contenedor_1:\n        context:  .     # ruta relativa al archivo .dev\n        dockerfile: Dockerfile.dev  #se carga la plantilla de desarrollo\n        ports:\n          #...\n</code></pre></p>","tags":["Docker","Podman"]},{"location":"docker/compose/compose/#ejecucion_1","title":"Ejecuci\u00f3n","text":"<p>Para operar con estos archivos se usa la opci\u00f3n <code>-f</code>del comando <code>docker compose</code>:</p>","tags":["Docker","Podman"]},{"location":"docker/compose/compose/#creacion-automatica_1","title":"Creaci\u00f3n autom\u00e1tica","text":"<pre><code>docker compose -f docker-compose-dev.yml up\n</code></pre>","tags":["Docker","Podman"]},{"location":"docker/compose/compose/#eliminacion-automatica-probarr","title":"Eliminaci\u00f3n autom\u00e1tica (PROBARR)","text":"<pre><code>docker compose -f docker-compose-dev.yml  down\n</code></pre>","tags":["Docker","Podman"]},{"location":"docker/compose/compose/#podmannnnnn","title":"PODMANNNNNN","text":"<p>Podman no trae incluida las herramientas para trabajar con archivos <code>docker-compose.yml</code>. Sin embargo, existen paquetes adicionales qu</p> <p>https://www.redhat.com/sysadmin/podman-docker-compose</p>","tags":["Docker","Podman"]},{"location":"docker/compose/compose/#referenciatus","title":"REFERENCIATUS!!!","text":"<p>https://compose-spec.io</p> <p>https://github.com/compose-spec/compose-spec/blob/main/spec.md</p> <p>https://docs.docker.com/reference/compose-file/</p>","tags":["Docker","Podman"]},{"location":"docker/compose/compose/#networking","title":"NETWORKING!!!","text":"<p>Newtworking</p>","tags":["Docker","Podman"]},{"location":"docker/compose/compose/#secretosss","title":"SECRETOSSS!!!!","text":"<p>Docker Docs - Secrets </p> <p>Secrets top-level elements</p>","tags":["Docker","Podman"]},{"location":"docker/compose/compose/#docker-compose-en-podman","title":"<code>docker compose</code> en Podman","text":"<p>instalar <code>podman-docker</code> y <code>docker-compose</code></p> <p>Arrancar servicio Podman:</p> <pre><code>sudo systemctl start podman.socket\n</code></pre> <p>Verificar conexion:</p> <pre><code>sudo curl -H \"Content-Type: application/json\" --unix-socket /var/run/docker.sock http://localhost/_ping\n</code></pre>","tags":["Docker","Podman"]},{"location":"docker/compose/compose/#referencias","title":"Referencias","text":"<p>Red Hat - Using Podman and Docker Compose</p> <p>Linux Config.org - How to use docker-compose with Podman on Linux</p> <p>Docker Docs - Volumes top-level element</p>","tags":["Docker","Podman"]},{"location":"docker/dockerfile/argumentos/","title":"Argumentos","text":"<p>Los argumentos permiten asignar valores a algunos par\u00e1metros internos del Dockerfile. Permiten pasar desde la shell tanto variables comunes como a variables de entorno.</p>","tags":["Docker","Podman"]},{"location":"docker/dockerfile/argumentos/#variables","title":"Variables","text":"<p>Se definen dentro del Dockerfile  con la cl\u00e1usula <code>ARG</code>  y traen un valor predefinido:</p> Argumentos - definici\u00f3n<pre><code>ARG VERSION=latest\nFROM imagen_base:${VERSION}\n#...\n</code></pre>","tags":["Docker","Podman"]},{"location":"docker/dockerfile/argumentos/#modificacion","title":"Modificaci\u00f3n","text":"<p>Los valores de los argumentos pueden ser modificados durante la construcci\u00f3n de la imagen con la opci\u00f3n <code>--build-arg</code>:</p> DockerPodman Argumentos - nuevo valor<pre><code>docker build --build-arg VERSION=18.04 .\n</code></pre> Argumentos - nuevo valor<pre><code>podman build --build-arg VERSION=18.04 .\n</code></pre>","tags":["Docker","Podman"]},{"location":"docker/dockerfile/argumentos/#visibilidad","title":"Visibilidad","text":"<p>Cada variable debe ser redefinida en cada etapa (stage) implementada dentro del Dockerfile.</p>","tags":["Docker","Podman"]},{"location":"docker/dockerfile/argumentos/#variables-de-entorno","title":"Variables de entorno","text":"<p>Las variables de entorno usan la cl\u00e1usula <code>ENV</code>. Estas variables pueden apoyarse en valores de argumentos tanto para recibir los valores por defecto  como para ser modificadas durante la construcci\u00f3n:</p> <pre><code>ARG NODE_ENV=production\nENV NODE_ENV=${NODE_ENV}\n</code></pre>","tags":["Docker","Podman"]},{"location":"docker/dockerfile/basico/","title":"Configurar im\u00e1genes","text":"","tags":["Python","Docker","Podman"]},{"location":"docker/dockerfile/basico/#dockerfile","title":"Dockerfile","text":"<p>Las im\u00e1genes no se crean ni modifican directamente mediante el uso de comandos, sino que se recurre al uso de un archivo de configuraci\u00f3n especial.  Este archivo suele llamarse <code>Dockerfile</code>  y nos permite configurar nuevas im\u00e1genes en base a una preexistente donde se incluyan nuevos comandos y aplicaciones. El <code>Dockerfile</code> sirve de plantilla para el comando build, el cual es el encargado de leer todas las configuraciones y volcarlas en una nueva imagen.</p> <p>Containerfile vs Dockerfile</p> <p><code>Dockerfile</code> es el nombre m\u00e1s habitual para el archivo de creaci\u00f3n de imagen debido a la gran popularidad de Docker;  sin embargo la norma es el uso del nombre gen\u00e9rico <code>Containerfile</code>.</p>","tags":["Python","Docker","Podman"]},{"location":"docker/dockerfile/basico/#sintaxis","title":"Sintaxis","text":"<p>Los archivos <code>Dockerfile</code> suelen tener una sintaxis como la siguiente:</p> Dockerfile - sintaxis gen\u00e9rica<pre><code>FROM imagen_base:version\n\nRUN mkdir -p \"ruta_ejecutables\"\n\nRUN comandos_instalacion \n\nWORKDIR \"ruta_entorno\"\n\nCOPY \"ruta_host\" \"ruta_interna\"\n\nEXPOSE numero_puerto\n\nCMD [ \"comando\" , \"ruta_ejecutable\" ]\n</code></pre>","tags":["Python","Docker","Podman"]},{"location":"docker/dockerfile/basico/#clausulas-basicas","title":"Cl\u00e1usulas b\u00e1sicas","text":"<p>Aqu\u00ed se ven los comandos m\u00e1s habituales:</p>","tags":["Python","Docker","Podman"]},{"location":"docker/dockerfile/basico/#from","title":"<code>FROM</code>","text":"<p>La cl\u00e1usula <code>FROM</code> especifica la imagen que servir\u00e1 de base para crear la nueva imagen. T\u00edpicamente es una imagen de alguna distribuci\u00f3n de Linux  (t\u00edpicamente Ubuntu, Debian, Alpine) o alguna imagen ya derivada de estas, la cual puede incluir:</p> <ul> <li>Int\u00e9rpretes y entornos de ejecuci\u00f3n para lenguajes: Python, NodeJS, Golang, etc;</li> <li>frameworks espec\u00edficos: Express, Flask, etc.</li> <li>Servidores web prearmados: Apache, NGINX, etc.</li> </ul> <p>Esta cl\u00e1usula es de uso obligatorio.</p>","tags":["Python","Docker","Podman"]},{"location":"docker/dockerfile/basico/#run","title":"<code>RUN</code>","text":"<p>La cl\u00e1usula sirve para ordenar al kernel interno de la imagen la ejecuci\u00f3n de comandos espec\u00edficos como:</p> <ul> <li> <p>Administrar el sistema de archivos interno: </p> <ul> <li>crear archivos y carpetas; </li> <li>mover elementos de ubicaci\u00f3n; </li> <li>administrar permisos internos de ser necesario; </li> <li>etc.</li> </ul> </li> <li> <p>Descargar e instalar paquetes de la distribuci\u00f3n;</p> </li> <li>Usar el gestor de paquetes del lenguaje de programaci\u00f3n a utilizar: PIP, NPM, etc.</li> </ul> <p>Esta cl\u00e1usula puede invocarse m\u00faltiples veces.</p>","tags":["Python","Docker","Podman"]},{"location":"docker/dockerfile/basico/#copy","title":"<code>COPY</code>","text":"<p>Esta cl\u00e1usula copia contenidos del sistema anfitri\u00f3n al interior de la futura imagen: rutinas, bibliotecas, ejecutables, etc. De esta forma los contenedores podran tener acceso a los mismos. </p> <p>Aislamiento</p> <p>Recordemos: los contenedores no pueden acceder a los archivos del sistema anfitri\u00f3n, a menos que se les de acceso expl\u00edcito mediante el uso de volumenes.</p>","tags":["Python","Docker","Podman"]},{"location":"docker/dockerfile/basico/#workdir","title":"<code>WORKDIR</code>","text":"<p>Esta cl\u00e1usula cambia el directorio de ejecuci\u00f3n de la shell interna de la imagen. Afecta al uso del comando o int\u00e9rprete interno del futuro contenedor.</p> <p>Directorio para ejecutables</p> <p>Una ruta habitual para ubicar los ejecutables dentro de la imagen es <code>/home/app</code>.  Este directorio debe ser creado para su uso.</p>","tags":["Python","Docker","Podman"]},{"location":"docker/dockerfile/basico/#expose","title":"<code>EXPOSE</code>","text":"<p>En el Dockerfile, <code>EXPOSE</code> proporciona la metadata del puerto usado para la imagen.  No es obligatorio incluirlo; sin embargo es buena pr\u00e1ctica incluirlo cuando la imagen usa puertos est\u00e1ticos.</p> <p>Puertos IP</p> <p>Los gestores de contenedores usan el protocolo IP  (n\u00famero de IP + puerto)  tanto para hacer funcionar los contendores  como para interconectarlos. Por este motivo cada imagen define un n\u00famero de puerto que ser\u00e1 heredado por el contenedor para poder ser utilizado. </p> <p>En el caso de usar puertos din\u00e1micos el <code>EXPOSE</code> es dif\u00edcil de especificar.</p>","tags":["Python","Docker","Podman"]},{"location":"docker/dockerfile/basico/#cmd-y-entrypoint","title":"<code>CMD</code> y <code>ENTRYPOINT</code>","text":"<p>La cl\u00e1usula <code>CMD</code> es t\u00edpicamente la cl\u00e1usula final del Dockerfile. Es la encargada de ordenar el arranque del int\u00e9rprete o comando interno y asignarle la rutina embebida por el desarrollador.</p> Rutina \u00fanica - CMD<pre><code># Servidor Python \nCMD [\"python\", \"/usr/src/myapp/server.py\"]\n</code></pre> <p>de esta la rutina interna entrar\u00e1 en funcionamiento en cuanto arranque el contenedor.  Por ejemplo, si la rutina implementa un servidor en Python el arranque de su contenedor es:</p> CMD - Uso en contenedor<pre><code>docker start servidor_python\n</code></pre> <p>Su alternativa es la cl\u00e1usula <code>ENTRYPOINT</code> el cual permite llamar al comando o int\u00e9rprete interno pero sin indicarle rutinas ni argumentos:</p> Rutina externa - ENTRYPOINT<pre><code># Int\u00e9rprete Python encapsulado \nENTRYPOINT [\"python\"]\n</code></pre> <p>los cuales ser\u00e1n pasados como argumentos del contenedor al ponerlo en marcha. Ejemplo:</p> ENTRYPOINT - Uso en contenedor<pre><code>docker start contenedor_python  rutina_externa.py\n</code></pre> <p>El uso de una de estas cl\u00e1usulas es obligatoria.</p>","tags":["Python","Docker","Podman"]},{"location":"docker/dockerfile/basico/#comandos-resumen","title":"Comandos (resumen)","text":"<p>La funci\u00f3n resumida de cada comando es la siguiente:</p> Cl\u00e1usula Argumentos Uso <code>FROM</code> <code>nombre_imagen:tag</code> Elige una imagen preexistente que servir\u00e1 de referencia <code>RUN</code> <code>comando_completo</code> Ejecuta comandos en Bash para crear directorios e instalar software <code>COPY</code> <code>ruta_host  ruta_interna</code> Copia archivos del host a la futura imagen <code>WORKDIR</code> <code>ruta_trabajo</code> Cambia la ruta interna del entorno de ejecuci\u00f3n <code>EXPOSE</code> <code>numero_puerto</code> Especifica el N\u00ba de puerto para conectar con la imagen (informativo) <code>CMD</code> <code>[comando, rutina_interna]</code> Llama al ejecutable interno y le especifica una rutina interna como argumento <code>ENTRYPOINT</code> <code>[comando]</code> Llama al ejecutable interno pero exigiendo uno o varios argumentos externos <code>ENV</code> <code>nombre_variable  valor</code> Define variables de entorno para la imagen <code>USER</code> <code>usuario_o_id</code> Define el usuario por su nombre o por su id <p>No es obligatorio especificar todos los campos, sino que estos se indican o no  seg\u00fan se necesite.</p> <p>Ejemplo: ejecutables en Python</p> <p>La imagen oficial de Python 3 propone la siguiente plantilla para crear im\u00e1genes derivadas:</p> <p><pre><code>FROM python:3\n\nWORKDIR /usr/src/app\n\nCOPY requirements.txt ./\nRUN pip install --no-cache-dir -r requirements.txt\n\nCOPY . .\n\nCMD [ \"python\", \"./script_python.py\" ]\n</code></pre> donde <code>requirements.txt</code> es el archivo con la lista de todos los paquetes de Python a incluir adentro de la imagen.</p>","tags":["Python","Docker","Podman"]},{"location":"docker/dockerfile/basico/#referencias","title":"Referencias","text":"<p>Docker Docs - Writing a Dockerfile</p>","tags":["Python","Docker","Podman"]},{"location":"docker/dockerfile/build/","title":"Editar Im\u00e1genes","text":"<p>A menudo es necesario modificar las im\u00e1genes preexistentes para poder crear las nuevas aplicaciones.  Para poder crearlas es indispensable crear primero los archivos de configuraci\u00f3n, conocidos t\u00edpicamente como archivos Dockerfile.</p>","tags":["Docker","Podman"]},{"location":"docker/dockerfile/build/#crear-imagenes-build","title":"Crear im\u00e1genes - <code>build</code>","text":"<p>La imagen nueva se construye con el comando <code>build</code>:</p> DockerPodman Crear imagen<pre><code>docker build  ruta_Dockerfile\n</code></pre> Crear imagen<pre><code>podman build  ruta_Dockerfile\n</code></pre> <p>Con \u00e9l se construye una imagen a partir del archivo Dockerfile disponible en la ruta indicada, la cual puede ser absoluta o relativa. El resultado es una imagen nueva sin nombre pero con un identificador \u00fanico.</p> <p>Para facilitar el manejo de las im\u00e1genes se les asigna un nombre y una etiqueta de versi\u00f3n:</p> DockerPodman Crear imagen - con nombre y versi\u00f3n<pre><code>docker build -t nombre_imagen:tag_version  ruta_Dockerfile\n</code></pre> Crear imagen - con nombre y versi\u00f3n<pre><code>docker build -t nombre_imagen:tag_version  ruta_Dockerfile\n</code></pre> <p>Si la terminal ya est\u00e1 ubicada en el directorio ra\u00edz de la aplicaci\u00f3n hay que poner un punto: </p> DockerPodman Crear imagen - directorio actual<pre><code>cd ruta_Dockerfile\ndocker build -t nombre_imagen:numero_version  .\n</code></pre> Crear imagen - directorio actual<pre><code>cd ruta_Dockerfile\npodman build -t nombre_imagen:numero_version  .\n</code></pre> <p>La imagen creada  aparecer\u00e1 incluida en la lista de im\u00e1genes locales y podr\u00e1 ser utilizada como cualquier imagen prefabricada  para crear nuevos contenedores.</p> <p>Por ejemplo, para crear una imagen de nombre <code>miapp</code> y su tag de versi\u00f3n es <code>latest</code> el comando ser\u00e1:</p> DockerPodman <pre><code>docker build -t miapp:latest .\n</code></pre> <pre><code>podman build -t miapp:latest .\n</code></pre>","tags":["Docker","Podman"]},{"location":"docker/dockerfile/build/#nombrar-imagenes-tag","title":"Nombrar imagenes - <code>tag</code>","text":"<p>Las im\u00e1genes ya creadas se renombran f\u00e1cilmente con ayuda del comando <code>tag</code>:</p> DockerPodman <pre><code>docker tag nombre_actual nuevo_nombre:tag_version   # por nombre\ndocker tag id_imagen     nuevo_nombre:tag_version   # por ID\n</code></pre> <pre><code>podman tag nombre_actual nuevo_nombre:tag_version   # por nombre\npodman tag id_imagen     nuevo_nombre:tag_version   # por ID\n</code></pre> <p>Debe tenerse en cuenta que una misma imagen puede tener varias etiquetas en simult\u00e1neo. </p>","tags":["Docker","Podman"]},{"location":"docker/dockerfile/build/#compartir-imagen-push","title":"Compartir imagen - <code>push</code>","text":"<p>Los gestores de contenedores  implementan sus propio cliente local  para poder publicar nuestras im\u00e1genes online. Esto presupone que ya estamos registrados en eel servidor online.</p> <p>Para ello,  nos identificamos localmente con usuario y contrase\u00f1a para que el cliente local pueda subir la imagen a nuestro nombre en el servidor.  Todo esto se realiza con el omando <code>login</code>:</p> DockerPodman Login - Docker Hub<pre><code>docker login\n</code></pre> Login - Red Hat<pre><code>podman login\n</code></pre> <p>N\u00f3tese que el destino predefinido para las im\u00e1genes de Docker es Docker Hub,  en tanto que para Podman el destino es Red Hat.</p> <p>Ordenamos el env\u00edo de nuestra imagen al servidor para publicarla,  usando el comando <code>push</code>:</p> DockerPodman Publicar<pre><code>docker push mi_imagen:tag_version\n</code></pre> Publicar<pre><code>podman push mi_imagen:tag_version\n</code></pre> <p>Docker Hub</p> <p>Docker Hub da alojamiento gratuito a las im\u00e1genes que sean compartidas p\u00fablicamente por los usuarios.</p>","tags":["Docker","Podman"]},{"location":"docker/dockerfile/optimizar/","title":"Optimizar Im\u00e1genes","text":"","tags":["Docker","Podman"]},{"location":"docker/dockerfile/optimizar/#ventajas","title":"Ventajas","text":"<ul> <li>Despliegues y registros m\u00e1s veloces;</li> <li>Reducir costos de almacenamiento en nube;</li> <li>Minimzar vulnerabilidades internas;</li> <li>Arranques de contenedores m\u00e1s veloces;</li> <li>Manejo de contenedores m\u00e1s eficiente.</li> </ul>","tags":["Docker","Podman"]},{"location":"docker/dockerfile/optimizar/#imagenes-minimalistas","title":"Im\u00e1genes minimalistas","text":"<p>Un buen punto de partida consiste en elegir una imagen  lo m\u00e1s reducida posible (minimal flavors) en cuanto a espacio ocupado y componentes internos.</p> <p>Las distribuciones de Linux m\u00e1s habituales son Ubuntu, Debian y Alpine. Entre ellas, Alpine es con diferencia la m\u00e1s liviana y reducida:</p> <p>Imagen compacta<pre><code>FROM alpine\n</code></pre> sin embargo esta opci\u00f3n no da el mejor rendimiento para todos los lenguajes posibles,  por ello debe ser usada con precauci\u00f3n.</p> <p>Una alternativa a\u00fan m\u00e1s compacta que <code>alpine</code> es el uso de im\u00e1genes distroless, por ejemplo:</p> Imagen distroless<pre><code># Imagen 'distroless'\nFROM gcr.io/distroless/static-debian11\n</code></pre>","tags":["Docker","Podman"]},{"location":"docker/dockerfile/optimizar/#dockerignore","title":"Dockerignore","text":"<p>El archivo oculto <code>Dockerignore</code> se usa para  prevenir la copia de contenidos innecesarios adentro de la imagen objetivo:</p> <ul> <li>carpetas de controles de versiones como Git (<code>.git</code>) o Subversion (<code>.svn</code>);</li> <li>paquetes descargados;</li> <li>archivos <code>.env</code>  y claves SSH;</li> <li>etc.</li> </ul> <p>Se usa de id\u00e9ntica manera que el archivo <code>gitignore</code> de Git. Ejemplo de uso:</p> Archivo Dockerignore - Ejemplo<pre><code># Control de versiones\n.git\n.svn\n.gitignore\n\n# Documentaci\u00f3n Markdown\n*.md\n</code></pre>","tags":["Docker","Podman"]},{"location":"docker/dockerfile/optimizar/#construccion-multi-stage","title":"Construcci\u00f3n Multi-Stage","text":"<p>Con este recurso se construyen las im\u00e1genes en dos etapas:</p> <ul> <li>La primera etapa sirve para instalar todas las dependencias y, de ser necesario, compilar archivos ejecutables. A esta etapa se la suele llamar <code>builder</code> (constructora).</li> <li>La segunda etapa consiste en copiar los archivos estrictamente necesarios a la imagen final, la cual est\u00e1 basada en una imagen compatible lo m\u00e1s minimalista posible.</li> </ul> <p>As\u00ed se ve un Dockerfile multietapa:</p> Dockerfile - Multi-Stage<pre><code># Etapa construccion\nFROM imagen_builder AS builder\nRUN  comandos_instalacion\n# ...\n\n# Etapa final\nFROM imagen_final\n# ...\nCOPY  --from=builder  ruta_builder  ruta_final\nCMD [\"comando\", \"argumento\"]\n</code></pre> <p>Para que la imagen final funcione correctamente  es necesario que la imagen final de referencia sea compatible  con la imagen usada para la construcci\u00f3n. Por ejemplo, si la imagen final es una imagen de Alpine Linux es prudente elegir una imagen builder derivada de Alpine Linux.</p> Dockerfile - Multi-Stage con Alpine<pre><code># Etapa construccion\nFROM golang:1.21-alpine AS builder\n# ...\n\n# Etapa final\nFROM alpine:3.18\nCOPY -FROM=builder ruta_app\n# ...\n</code></pre> <p>El mismo criterio se aplica para im\u00e1genes basadas en Debian y Ubuntu.</p> <p>Otras etapas posibles: <code>build</code>, <code>dev</code>, <code>test</code>, <code>lint</code>.</p> <p>Dockerfile con test</p> <p>Si se crea la imagen en varias etapas y se desea incorporar una etapa de tests unitarios estos pueden tener su propia etapa:</p> Etapas Builder y Test<pre><code>FROM imagen1:version AS builder\n# ... (instrucciones instalacion)\n\nFROM imagen2:version AS TEST\nCOPY -FROM=builder ruta_app\nCMD [test]\n\n\nFROM imagen2:version AS builder\nCOPY -FROM=builder ruta_app\nCMD [orden]\n</code></pre>","tags":["Docker","Podman"]},{"location":"docker/dockerfile/optimizar/#optimizar-capas","title":"Optimizar capas","text":"<p>Cada instrucci\u00f3n del Dockerfile crea una nueva capa (layer) de la nueva imagen.</p> <p>Para minimizar las capas de la imagen final y optimizar su tama\u00f1o se pueden seguir varias estrategias complementarias.</p>","tags":["Docker","Podman"]},{"location":"docker/dockerfile/optimizar/#ordenar-instrucciones","title":"Ordenar instrucciones","text":"<p>Para una mejor construcci\u00f3n es mejor colocar las instrucciones que cambian con menos frecuencia al final. De esta manera se reutilizan las capas preconstruidas en caso que no se detecten cambios.</p> <p>Por ejemplo,  las rutinas de programaci\u00f3n cambian frecuentemente  y por ello  es mejor copiarlas adentro de la imagen al final,  justo antes de ordenar la ejecuci\u00f3n.</p> <p>En cambio, las dependencias cambian con poca frecuencia  y por eso se las instalaciones se hacen cerca del comienzo. </p>","tags":["Docker","Podman"]},{"location":"docker/dockerfile/optimizar/#combinar-comandos-run","title":"Combinar comandos <code>RUN</code>","text":"<p>Las instrucciones se instalaci\u00f3n de dependencias m\u00faltiples se pueden combinar para dar forma a una \u00fanica capa.</p> <p>Por ejemplo,  si el archivo <code>Dockerfile</code> tiene originalmente esta forma:</p> <p><pre><code># instalaci\u00f3n de dependencias\nRUN instalar dependencia_1\nRUN instalar dependencia_2\nRUN ...\nRUN instalar dependencia_n\n# borrado de cach\u00e9\nRUN rm ruta_cache\n</code></pre> entonces se crear\u00e1 un layer por cada dependencia. Los layers se unifican de esta manera:</p> <p><pre><code>RUN instalar dependencia_1 \\\n    dependencia_2 \\\n    ... \\\n    dependencia_n \n&amp;&amp; rm ruta_cache\n</code></pre> donde el s\u00edmbolo <code>&amp;&amp;</code> permite concatenar comandos  en tanto que <code>\\</code> permite concatenar los argumentos de un mismo comando.</p> <p>Limpiar layers</p> <p>Es una buena pr\u00e1ctica aprovechar  cada instrucci\u00f3n RUN relacionada con la instalaci\u00f3n de dependencias para eliminar los archivos descargados y desempaquetados dentro de la imagen.</p>","tags":["Docker","Podman"]},{"location":"docker/dockerfile/optimizar/#usar-copy-en-vez-de-add","title":"Usar <code>COPY</code> en vez de <code>ADD</code>","text":"<p>Docker Docs - <code>ADD</code> or <code>COPY</code></p>","tags":["Docker","Podman"]},{"location":"docker/dockerfile/optimizar/#comando-history","title":"Comando <code>history</code>","text":"<p>El comando <code>history</code> sirve para listar el historial de capas y sus cambios a lo largo del tiempo.</p> DockerPodman Historial de capas<pre><code>docker history imagen:tag\n</code></pre> Historial de capas<pre><code>podman history imagen:tag\n</code></pre>","tags":["Docker","Podman"]},{"location":"docker/dockerfile/optimizar/#comando-scout","title":"Comando <code>scout</code>","text":"<p>El comando <code>scout</code> sirve para buscar vulnerabilidades conocidas en la imagen objetivo y reportarlas.</p> Buscar vulnerabilidades<pre><code>docker scout cve imagen:tag\n</code></pre> <p>(S\u00f3lo disponible en Docker).</p>","tags":["Docker","Podman"]},{"location":"docker/dockerfile/optimizar/#referencias","title":"Referencias","text":"<p>DevDojo.com - Optimizing Docker Image Sizes: Advanced Techniques and Tools</p>","tags":["Docker","Podman"]},{"location":"extras/ejemplos/","title":"Ejemplos","text":"<p>Este primer ejemplo conecta una rutina escrita en JavaScript con una base de datos en MongoDB. Se trata de guardar un registro con contenido \"chanchito\" cada vez que se visita la URL local:</p> <p><pre><code>http:localhost:3000/crear\n</code></pre> Y los registros creados se consultar\u00e1n con la URL local ra\u00edz:</p> <pre><code>http:localhost:3000\n</code></pre> <p>Repositorio de ejemplo en GitHub</p>"},{"location":"extras/ejemplos/#contenedor-mongodb","title":"Contenedor MongoDB","text":"<pre><code>docker create -p 27017:27017 --name monguito  -e MONGO_INITDB_ROOT_USERNAME=nico -e MONGO_INITDB_ROOT_PASSWORD=password mongo\n</code></pre> <pre><code>docker start monguito\n</code></pre>"},{"location":"extras/ejemplos/#node-local-preliminar","title":"Node Local (preliminar)","text":"<p>Instalar localmente NodeJS y los paquetes: - <code>express</code> : servidor implementado en JavaScript  - <code>mongoose</code>: conector para MongoDB implementado en JavaScript </p> <pre><code>npm install mongoose express\n</code></pre> <p>Hay que revisar que la rutina <code>index.js</code> indique la conexi\u00f3n al equipo local <code>localhost</code>:</p> <pre><code>mongoose.connect('mongodb://nico:password@localhost:27017/miapp?authSource=admin')\n// mongoose.connect('mongodb://nico:password@monguito:27017/miapp?authSource=admin')\n</code></pre> <p>Ejecutar archivo JS.</p> <pre><code>node index.js \n</code></pre> <p>El sistema deber\u00eda responder correctamente....</p>"},{"location":"extras/ejemplos/#red-de-docker","title":"Red de Docker","text":"<p>Se crea una red puente para poder interconectar a futuro los contenedores del proyecto. S\u00f3lo se necesita darle un nombre:</p> <pre><code>docker network create mired\n</code></pre>"},{"location":"extras/ejemplos/#nodejs-en-contenedor","title":"NodeJS en contenedor","text":""},{"location":"extras/ejemplos/#corregir-rutina-js","title":"Corregir rutina JS","text":"<p>Ahora la rutina <code>index.js</code> debe conectarse al contenedor de MongoDB:</p> <pre><code>// mongoose.connect('mongodb://nico:password@localhost:27017/miapp?authSource=admin')\nmongoose.connect('mongodb://nico:password@monguito:27017/miapp?authSource=admin')\n</code></pre>"},{"location":"extras/ejemplos/#crear-imagen-con-rutina-js","title":"Crear imagen con rutina JS","text":"<p>Se construye la imagen que contendr\u00e1 tanto la rutina JS como las dependencias (NodeJS) con ayuda del archivo <code>Dockerfile</code>:</p> <pre><code>FROM node:18\n\nRUN mkdir -p /home/app\n\nCOPY . /home/app\n\nEXPOSE 3000\n\nCMD [\"node\", \"/home/app/index.js\"]\n</code></pre> <p>La imagen se crea con el comando <code>build</code>:</p> <pre><code># ruta actual del archivo Dockerfile\ndocker build -t miapp:v1 .\n</code></pre>"},{"location":"extras/ejemplos/#rehacer-contenedor-mongodb","title":"Rehacer contenedor MongoDB","text":"<p>Debe incluirse la conexion a la red bridge del proyecto</p> <pre><code>docker create -p 27017:27017 --name monguito --network mired  -e MONGO_INITDB_ROOT_USERNAME=nico -e MONGO_INITDB_ROOT_PASSWORD=password mongo\n</code></pre>"},{"location":"extras/ejemplos/#crear-contenedor-js","title":"Crear contenedor JS","text":"<p>Se crea el contenedor de la rutina JS con el mapeo IP y la referencia a la red bridge con ayuda de la imagen creada previamente</p> <pre><code>docker create -p 3000:3000 --name chanchito --network mired   miapp:v1\n</code></pre>"},{"location":"extras/ejemplos/#puesta-en-marcha","title":"Puesta en marcha","text":"<pre><code>docker start monguito chanchito\n</code></pre> <p>verificacion:</p> <pre><code>docker logs chanchito\ndocker logs monguito \n</code></pre>"},{"location":"extras/ejemplos/#montar-con-docker-compose","title":"Montar con Docker Compose","text":"<p>La alternativa simplificadora a los pasos previos es el uso del archivo <code>docker-compose.yml</code>. En \u00e9l se agregan las opciones de configuraci\u00f3n, asignaciones de im\u00e1genes , construcci\u00f3n autom\u00e1tica de im\u00e1genes, etc </p> <pre><code># archivo 'docker-compose.yml'\nversion: \"3.9\"\nservices:\n\n  # contenedor con interfaz NodeJS\n  chanchito:\n    build: .    # construccion de imagen - archivo Dockerfile local\n    ports:\n      - \"3000:3000\"\n    links:\n      - monguito\n\n  # contenedor MongoDB \n  monguito:\n    image: mongo    # lectura de imagen MongoDB\n    ports:\n      - \"27017:27017\"\n    environment:\n      - MONGO_INITDB_ROOT_USERNAME=nico\n      - MONGO_INITDB_ROOT_PASSWORD=password\n</code></pre> <p>Puesta en marcha:</p> <pre><code>docker compose up\n</code></pre>"},{"location":"extras/ejemplos/#agregar-volumenes","title":"Agregar vol\u00famenes","text":"<p>Los vol\u00famenes se agregan al archivo <code>docker-compose.yaml</code></p> <pre><code># archivo 'docker-compose.yml'\nversion: \"3.9\"\nservices:\n\n  # contenedor con interfaz NodeJS\n  chanchito:\n    build: .    # construccion de imagen - archivo Dockerfile local\n    ports:\n      - \"3000:3000\"\n    links:\n      - monguito\n\n  # contenedor MongoDB \n  monguito:\n    image: mongo    # lectura de imagen MongoDB\n    ports:\n      - \"27017:27017\"\n    environment:\n      - MONGO_INITDB_ROOT_USERNAME=nico\n      - MONGO_INITDB_ROOT_PASSWORD=password\n    volumes:\n      # database dentro de un 'volume' \n      - mongo-data:/data/db\n\nvolumes:\n  mongo-data:\n</code></pre> <p>Hace falta eliminar los viejos contenedores para poder reconstruirlos:</p> <pre><code>docker compose down\n</code></pre> <p>Puesta en marcha:</p> <pre><code>docker compose up\n</code></pre> <p>Ahora los registros creados por MongoDB son persistentes:  ya no son reiniciados con cada nuevo container creado.</p>"},{"location":"extras/ejemplos/#version-desarrollo-hot-reload","title":"Version desarrollo - Hot Reload","text":"<p>Como versi\u00f3n de desarrollo se reemplaza a NodeJS por Nodemon, el cual es una variante de NodeJS que permite el hot-reload (ejecuci\u00f3n en modo debug, detecta cambios en la rutina JavaScript \"en vivo\").</p> <p>Para esto crea el archivo <code>Dockerfile.dev</code>, con las instrucciones modificadas:</p> <pre><code>FROM node:18\n\n# Instalar Nodemon desde Node via NPM\nRUN npm i -g nodemon        \n\nRUN mkdir -p /home/app\n\nWORKDIR /home/app\n\nEXPOSE 3000\n\nCMD [\"nodemon\", \"index.js\"]\n</code></pre> <p>Luego se arma el nuevo archivo </p> <pre><code>version: \"3.9\"\nservices:\n\n  chanchito:\n    build:\n      context: .\n      dockerfile: Dockerfile.dev\n    ports:\n      - \"3000:3000\"\n    links:\n      - monguito\n    volumes:\n      # ejecutable JS dentro de un 'volume' sin nombre \n      - .:/home/app\n\n  monguito:\n    image: mongo\n    ports:\n      - \"27017:27017\"\n    environment:\n      - MONGO_INITDB_ROOT_USERNAME=nico\n      - MONGO_INITDB_ROOT_PASSWORD=password\n    volumes:\n      # database dentro de un 'volume' \n      - mongo-data:/data/db\n\nvolumes:\n  mongo-data:\n</code></pre> <p>Construcci\u00f3n y puesta en marcha agregando la opci\u00f3n <code>-f</code> y el nombre de archivo YAML:</p> <pre><code>docker compose -f docker-compose-dev.yml up\n</code></pre>"},{"location":"extras/extras/","title":"Extras","text":""},{"location":"extras/extras/#cmd-run-y-entrypoint-en-dockerfile","title":"CMD, RUN y ENTRYPOINT en Dockerfile","text":"<p>DIFERENCIA entre CMD, RUN, y ENTRYPOINT en DOCKER - V2M</p> <ul> <li><code>RUN</code>: permite ejecutar un comando en espec\u00edfico durante la creacion de la imagen. Ejemplo:     <pre><code>RUN pip install fastapi\n</code></pre></li> <li> <p><code>CMD</code>: ejecuta una rutina interna especifica al arrancar el contenedor. Ejemplo: un servidor hecho en Python</p> <pre><code>CMD [\"python\", \"/usr/src/myapp/server.py\"]\n</code></pre> </li> <li> <p><code>ENTRYPOINT</code>: llama al ejecutable interno al arrancar el contenedor,  pero dependiendo de uno o varios argumentos externos. Ejemplo: el int\u00e9rprete de Python encapsulado en un contenedor.</p> <pre><code>ENTRYPOINT [\"python\"]\n</code></pre> </li> </ul> <p>El contenedor ejecuta la rutina que se le indique como argumento:</p> <pre><code>```bash\ndocker run contenedor-python  ruta_rutina.py\n```\n</code></pre>"},{"location":"extras/extras/#multiples-contenedores","title":"Multiples contenedores","text":"<p>INFO: en los archivos <code>docker-compose.yml</code> las redes y sus alias se crean autom\u00e1ticamente</p>"},{"location":"extras/extras/#mas-optimizing-docker-image-sizes-advanced-techniques-and-tools","title":"MAS: Optimizing Docker Image Sizes: Advanced Techniques and Tools","text":"<ul> <li>construccion de imagenes en dos fases</li> <li>archivo dockerignore</li> <li>optimizaciones por lenguaje</li> <li>y mucho mas</li> </ul>"},{"location":"extras/extras/#referencias","title":"Referencias","text":"<p>Alternativas a Docker</p> <p>CRI - Alternativa a Kubernetes</p> <p>RUNC , OCI y CRI</p> <p>Open Container Initiative</p> <p>FlatPak (no requiere daemon)</p> <p>FlatPack vs Snap</p> <p>Podman (Docker Sin Daemon)</p> <p>Las ventajas de Podman sobre Docker</p> <p>Podman Desktop</p> <p>Usando el Docker Compose en Podman</p> <p>Red Hat - Guia de contenedores</p>"},{"location":"extras/wsl/","title":"Configuraci\u00f3n de Docker: WSL","text":"<p>El WSL (Windows Subsystem for Linux) es el soporte para los containers de Docker. Hay dos versiones de WSL disponibles:</p> <ul> <li>la versi\u00f3n 1 que viene activada por defecto;</li> <li>la versi\u00f3n 2 que tiene algunas mejoras funcionales y mejor rendimiento. </li> </ul> <p>A cada una se le puede asignar una imagen de kernel,  sea de una distribuci\u00f3n Linux  (las m\u00e1s habituales son Alpine, Debian y Ubuntu)  o incluso Windows.  La distribuci\u00f3n m\u00e1s popular es Alpine Linux por sus bajos requisitos de memoria y de espacio en disco,  adem\u00e1s de su gran velocidad de ejecuci\u00f3n. Kernel Alpine descargable desde GitHub</p>"},{"location":"extras/wsl/#que-distros-tengo-en-wsl-win-10","title":"\u00bfQu\u00e9 distros tengo en WSL? (Win 10)","text":"<p>Enumerar qu\u00e9 distribuciones est\u00e1n instaladas y cu\u00e1l lo est\u00e1 por defecto:</p> <pre><code>wsl --list\n</code></pre> <p>Enumerar distribuciones disponibles online:</p> <pre><code>wsl --list --online\n</code></pre> <p>Si no hay ninguna act\u00faa una imagen predeterminada de Docker llamada docker-desktop, la cual tiene un importante consumo de recursos.</p> <p>Arranca la distribuci\u00f3n elegida: <pre><code>wsl -d      &lt;nombre_distro&gt;\n</code></pre></p> <p>Elegimos qu\u00e9 distribuci\u00f3n es la que queremos usar por defecto. <pre><code>wsl --set-default   &lt;nombre_distro&gt;\nwsl -s          &lt;nombre_distro&gt;\n</code></pre> Indica qu\u00e9 versi\u00f3n de WSL hace funcionar a cada kernel instalado y si est\u00e1 corriendo o no: <pre><code>wsl --list --verbose\n</code></pre></p> <p>Elige qu\u00e9 versi\u00f3n de WSL ejecuta el kernel elegido:</p> <pre><code>wsl --set-version &lt;nombre_distro&gt; &lt;numero_version&gt;\n</code></pre> <p>HINT:  ejecutar este comando con la terminal ubicada en la direccion del kernel a\u00f1adido,  esto es para prevenir errores tipo \u201cel archivo del kernel no debe estar comprimido\u201d etc.</p> <p>Elig\u00e9 qu\u00e9 version de WSL ejecutar habitualmente (se recomienda la 2):</p> <p><pre><code>wsl --set-default-version &lt;numero_version&gt;\n</code></pre> Reinicio del subsistema de Linux: <pre><code>wsl --shutdown\n</code></pre></p> <p>Para eliminar una distribuci\u00f3n de linux del WSL se puede hacer:</p> <pre><code>wsl --unregister  distribucion\n</code></pre> <p>https://www.windowscentral.com/how-completely-remove-linux-distro-wsl</p> <pre><code>wsl --import &lt;distribucion&gt; &lt;direccion_ instalacion&gt;\n</code></pre> <p>Configuraci\u00f3n en Windows: <code>wsl.conf</code> y <code>.wslconfig</code></p> <ul> <li><code>wsl.conf</code> \u2192 Archivo en la distribuci\u00f3n Linux / Docker usada. Ubicacion: <code>/etc/wsl.conf</code></li> <li><code>.wslconfig</code> \u2192 Archivo para Windows que va en la carpeta de usuario (si no existe se crea)</li> </ul>"},{"location":"k8s/cliente/","title":"Kubectl y complementos","text":""},{"location":"k8s/cliente/#kubectl","title":"Kubectl","text":"<p>Es el cliente de Kubernetes</p> <p>Consulta de versi\u00f3n (local):</p> <pre><code>kubectl version --client=true\n</code></pre> <p>Si se omite la opci\u00f3n <code>--client=true</code> entonces el cliente intentar\u00e1 descargar la versi\u00f3n del clod actual de Kubernetes y dar\u00e1 error.</p>"},{"location":"k8s/cliente/#instalar-cluster","title":"Instalar cluster","text":"<ul> <li>Docker Desktop</li> <li>Kind : utilidad para crear clusters locales con fines de desarrollo y testeo. p\u00e1gina de Kind</li> <li>Minikube: crea una m\u00e1quina virtual para correr Kubernetes. Acepta plugins.</li> </ul>"},{"location":"k8s/cliente/#proveedores-de-cloud","title":"Proveedores de Cloud","text":"<p>Proveedores de Cloud para Kubernetes:</p> <p>DigitalOcean, AWS, GoogleCloud, Linode, etc.</p>"},{"location":"k8s/cliente/#conexion-remota","title":"Conexion remota","text":"<p>En caso de usar un servicio de cloud hay que descargar un archivo de configuraciones, credenciales, etc. desde la p\u00e1gina web del servicio. Luego se crea una variable de entorno con la ruta al archivo de configuraci\u00f3n:</p> <pre><code>export KUBECONFIG=ruta_archivo_config\n</code></pre> <p>por ejemmplo si el archivo est\u00e1 en la carpeta de descargas de usuario: <pre><code>export KUBECONFIG=~/Downloads/nombre_archivo\n</code></pre> y la conexi\u00f3n se hace con el comando <code>get nodes</code> <pre><code>kubectl get nodes\n</code></pre></p>"},{"location":"k8s/cliente/#comandos","title":"Comandos","text":"<p>....</p> <p>Ver contextos: <pre><code>kubectl  config get-contexts\n</code></pre></p> <p>Recomendado: Lens (IDE para Kubernetes)</p>"},{"location":"k8s/cliente/#logs-y-stern","title":"logs y stern","text":"<pre><code>kubectl logs -f nombre_completo_pod\n</code></pre> <p>stern requiere instalaci\u00f3n</p> <pre><code>stern parte_nombre\n</code></pre>"},{"location":"k8s/cliente/#base64","title":"Base64","text":"<pre><code>echo admin | base64   # 'YWRtaW4K'\necho c3VwM3JwYXNzdzByZA== | base64 -d      # 'sup3rpassw0rd'\n</code></pre>"},{"location":"k8s/cliente/#kubesealed","title":"Kubesealed","text":"<p>Kubesealed - Cifrando secretos en Kubernetes</p>"},{"location":"k8s/cliente/#helm","title":"Helm","text":"<p>HELM: INSTAL\u00c1 WORDPRESS con 1 COMANDO en KUBERNETES</p> <p>GitHub de Helm</p>"},{"location":"k8s/cliente/#referencias","title":"Referencias","text":"<p>Pelado Nerd - KUBERNETES De NOVATO a PRO! (CURSO COMPLETO EN ESPA\u00d1OL)</p>"},{"location":"k8s/configmap/","title":"ConfigMap","text":"<p>El configMap es un archivo que se sube al servidor Kubernetes y al que los pods tendr\u00e1n acceso.</p> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: game-demo\ndata:\n  # property-like keys; each key maps to a simple value\n  player_initial_lives: \"3\"\n  ui_properties_file_name: \"user-interface.properties\"\n  #\n  # file-like keys\n  game.properties: |\n    enemy.types=aliens,monsters\n    player.maximum-lives=5\n  user-interface.properties: |\n    color.good=purple\n    color.bad=yellow\n    allow.textmode=true\n</code></pre> <pre><code>apiVersion: v1\nkind: Pod\nmetadata:\n  name: nginx\nspec:\n  containers:\n    - name: nginx\n      image: nginx:alpine\n      env:\n        # Define the environment variable\n        - name: PLAYER_INITIAL_LIVES # Nombre de la variable\n          valueFrom:\n            configMapKeyRef:\n              name: game-demo           # El confimap desde donde vienen los valores\n              key: player_initial_lives # La key que vamos a usar\n        - name: UI_PROPERTIES_FILE_NAME\n          valueFrom:\n            configMapKeyRef:\n              name: game-demo\n              key: ui_properties_file_name\n      volumeMounts:\n      - name: config\n        mountPath: \"/config\"\n        readOnly: true\n  volumes:\n    - name: config\n      configMap:\n        name: game-demo # el nombre del configmap que queremos montar\n        items: # Un arreglo de keys del configmap para crear como archivos\n        - key: \"game.properties\"\n          path: \"game.properties\"\n        - key: \"user-interface.properties\"\n          path: \"user-interface.properties\"\n</code></pre>","tags":["Kubernetes"]},{"location":"k8s/daemonset/","title":"DaemonSet","text":"<p>Los pods del tipo <code>DaemonSet</code> son desplegados en todos los nodos, uno por nodo. Sirven para hacer monitoreo.</p> <pre><code>apiVersion: apps/v1\nkind: DaemonSet\nmetadata:\n  name: nginx-deployment\nspec:\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n        # ...\n</code></pre>","tags":["Kubernetes"]},{"location":"k8s/deployment/","title":"Deployment","text":"<p>El manifiesto del tipo <code>Deployment</code> permite a Kubernetes poner en marcha y controlar a m\u00faltiples pods iguales llamados r\u00e9plicas.</p> <pre><code># archivo '04-deployment.yaml'\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:               # especificaciones del despliegue\n  selector:\n    matchLabels:\n      app: nginx\n  replicas: 2       # n1 de contenedores iguales internos\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:           # especificaciones de los containers   \n      containers:\n        #....       # configuracion de containers\n</code></pre> <p>La configuraci\u00f3n de los contenedores internos es igual a la usada con los pods.</p> <p>Si alguno de los pods creado es eliminado se crear\u00e1 uno nuevo autom\u00e1ticamente.</p>","tags":["Kubernetes"]},{"location":"k8s/ingress/","title":"Ingress","text":"<p><code>Ingress</code> permite el acceso a los servicios mediante el path de la URL. Kubernetes despliega un controlador NGINX dentro del cl\u00faster,  el cual se va a autoconfigurar para redireccionar el tr\u00e1fico a los servicios.</p> <p>El controlador ingress necesita ser instalado para su uso.</p> <p>Recomendado: Helm</p> <pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: hello-app\nspec:\n  rules:\n  - http:\n      paths:\n      - path: /v1\n        pathType: Prefix\n        backend:\n          service:\n            name: hello-v1\n            port:\n              number: 8080\n      - path: /v2\n        pathType: Prefix\n        backend:\n          service:\n            name: hello-v2\n            port:\n              number: 8080\n</code></pre> <p>Los manifiestos ingress se consultan con su propia opci\u00f3n:</p> <pre><code>kubectl get ing\n</code></pre> <p>El controlador Ingress suele crear tamb\u00ed\u00e9n un load balancer y configura la direcci\u00f3n IP</p> <pre><code>kubectl -n ingress-nginx get svc\n</code></pre> <p>Una vez creado el manifiesto ingress el funcionamiento se puede verificar con <code>curl</code>:</p> <pre><code>curl http://direcci\u00f3n_ip/v1\ncurl http://direcci\u00f3n_ip/v2\n</code></pre>","tags":["Kubernetes"]},{"location":"k8s/intro/","title":"Kubernetes","text":"<p>Kubernetes (o K8) es un orquestador de contenedores. El orquestador se encarga de gestionar m\u00faltiples servidores a la vez,  a los cuales les hace ejecutar un conjunto de contenedores predefinido.</p> <p>Esto permite:</p> <ul> <li>repartir el procesamiento entre varios servidores;</li> <li>dar confiabilidad a los servicios mediante la redundancia de servidores;</li> <li>gestionar los topes de recursos dedicados en cada servidor: uso de CPU, memoria RAM, etc;</li> <li>reiniciar servicios ca\u00eddos de manera autom\u00e1tica;</li> <li>etc.</li> </ul> <p>Recursos recomendados: Libros de SRE de Google</p>","tags":["Kubernetes"]},{"location":"k8s/intro/#componentes","title":"Componentes","text":"<p>Kubernetes es declarativo. El desarrollador crea un manifiesto  con el cual Kubernetes levanta un pod, el cual gestiona internamente los contenedores y las r\u00e9plicas.</p> <p>El servicio de cluster de Kubernetes recibe el manifiesto y trata de repartir las tareas entre los workers, los cuales son los servidores que ejecutar\u00e1n las tareas.</p> <p>El scheduler es el servicio que mueve los contenedores de un lugar al otro.</p> <p>kubelet es el agente que conecta a los workers con la API del servicio de cluster. </p> <p>De forma predefinida a cada worker se le asigna un pod para ejecutar las tareas.  Si alguno de los workers cae entonces su pod se pasar\u00e1 a otro worker.</p>","tags":["Kubernetes"]},{"location":"k8s/kubernetes/","title":"Kubernetes","text":""},{"location":"k8s/kubernetes/#networking","title":"Networking","text":""},{"location":"k8s/kustomization/","title":"Kustomization","text":"<pre><code>apiVersion: kustomize.config.k8s.io/v1beta1\nkind: Kustomization\n\ncommonLabels:\n  app: ejemplo\n\nresources:\n- 15-pod-secret.yaml\n\nsecretGenerator:\n- name: db-credentials\n  literals:\n  - username=admin\n  - password=secr3tpassw0rd!\n\nimages:\n- name: nginx\n  newTag: latest\n</code></pre>","tags":["Kubernetes"]},{"location":"k8s/manifiesto/","title":"Manifiestos (recursos)","text":"","tags":["Kubernetes"]},{"location":"k8s/manifiesto/#namespaces","title":"Namespaces","text":"<p>Son divisiones l\u00f3gicas del cluster de Kubernetes. Separan la carga pero no impiden la lectura de datos de uno a otro.</p> <pre><code>kubectl get ns\n</code></pre> NAME STATUS AGE <code>default</code> Active 37m <code>kube-node-lease</code> Active 37m <code>kube-public</code> Active 37m <code>kube-system</code> Active 37m <p>Los namespaces que comienzan con <code>kube</code> son reservados para las herramientas de Kubernetes. </p>","tags":["Kubernetes"]},{"location":"k8s/manifiesto/#pods","title":"Pods","text":"<p>Un pod es un conjunto de contenedores.  Se recomienda ejecutar un proceso por contenedor,  por ello de ejecutarse varios procesos juntos conviene asignar uno por contenedor y agrupar los contenedores mediante un pod. De esta forma Kubernetes monitorear\u00e1 y controlar\u00e1 autom\u00e1ticamente a todos los containers internos, cada uno con sus propias reglas.</p> <p>Consulta de pods para un namespace particular: <code>get pods</code> <pre><code>kubectl -n nombre_namespace get pods\n</code></pre></p> <p>ejemplo: namespace <code>kube-system</code> <pre><code>kubectl -n kube-system get pods\n</code></pre></p> <p>el comando indica estado del pod, tiempo de funcionamiento, veces que se reinici\u00f3, etc.</p> <p>Se muestra m\u00e1s informaci\u00f3n agregando <code>-o wide</code>: IP , nodo, etc. <pre><code>kubectl -n kube-system get pods -o wide\n</code></pre></p> <p>Cierre manual de un pod particular <pre><code>kubectl -n nombre_espacio delete pod nombre_pod \n</code></pre></p>","tags":["Kubernetes"]},{"location":"k8s/manifiesto/#crear-pod","title":"Crear pod","text":"<p>Recurso recomendado: manifiestos del Pelado Nerd en GitHub</p> <p>Creamos un manifiesto llamado <code>01-pod.yaml</code></p> <pre><code>apiVersion: v1\nkind: Pod\nmetadata:\n  name: nginx\nspec:\n  containers:\n  - name: nginx\n    image: nginx:alpine\n    ports:\n        - containerPort: 80\n</code></pre> <p>Cada tipo de pod requiere una versi\u00f3n especifica de API.</p> <p>El manifiesto se ejecuta con el comando <code>apply</code>:</p> <p><pre><code>kubectl apply -f 01-pod.yaml\n</code></pre> y se verifica el funcionamiento con <code>get pods</code>:</p> <pre><code>kubectl get pods\n</code></pre> <p>El pod construido en este caso se llama <code>nginx</code>.  Al no haber indicado un namespace el pod se crear\u00e1 en default.</p> <p>Para abrir una terminal interactiva adentro del pod se usa el comando <code>exec</code>:</p> <p><pre><code>kubectl exec -it nginx -- sh\n</code></pre> El acceso es otorgado por la API de Kubernetes.</p> <p>El pod se elimina con <code>delete</code></p> <pre><code>kubectl delete pod nginx\n</code></pre>","tags":["Kubernetes"]},{"location":"k8s/manifiesto/#variables-de-entorno","title":"Variables de entorno","text":"<pre><code># ...\nspec:\n  containers:\n    # ...   \n    env:\n    - name: MI_VARIABLE\n      value: \"pelado\"\n    - name: MI_OTRA_VARIABLE\n      value: \"pelade\"\n    - name: DD_AGENT_HOST\n      valueFrom:\n        fieldRef:\n          fieldPath: status.hostIP\n</code></pre>","tags":["Kubernetes"]},{"location":"k8s/manifiesto/#recursos","title":"Recursos","text":"<p>Con el campo <code>resources</code> se especifican tanto los recursos garantizados a cada pod (<code>requests</code>)  como los recursos l\u00edmite a los que pueden acceder entre todos ellos (<code>limits</code>).</p> <pre><code># ...\nspec:\n  containers:\n    # ...   \n    resources:\n      requests:\n        memory: \"64Mi\"      # memoria en megabytes\n        cpu: \"200m\"         # demanda de cores en mil\u00e9simas\n      limits:\n        memory: \"128Mi\"     # memoria en megabytes\n        cpu: \"500m\"         # demanda de cores en mil\u00e9simas\n</code></pre> <p><code>cpu</code> es el n\u00famero de cores (n\u00facleos) y se especifica habitualmente en mil\u00e9simas.  <code>memory</code> es la memoria RAM disponible y se especifica normalmente en MiBs. En este ejemplo,  <code>cpu:\"200m\"</code> indica que cada pod tiene garantizado el 20% del tiempo de uso de un core en tanto que el conjunto de pods disponen de hasta el 50% del tiempo de un n\u00facleo (<code>cpu: \"500m\"</code>). Por ello un mismo worker podr\u00eda ejecutar en simult\u00e1neo hasta 2 pods definidos por usuario.</p> <p>Debe se\u00f1alarse que en el l\u00edmite impuesto a los recursos incluye tambi\u00e9n a los pods del sistema.</p> <p>Si alg\u00fan pod intenta excederse en su consumo de RAM  entonces el kernel de Linux cerrar\u00e1 dicho pod autom\u00e1ticamente  e intentar\u00e1 crear uno nuevo.</p> <p>En cambio, si alg\u00fan pod intenta superar la demanda de CPU m\u00e1xima habilitada entonces el kernel de Linux lo \"ahogar\u00e1\" (CPU throttling) para reducir su demanda.</p>","tags":["Kubernetes"]},{"location":"k8s/manifiesto/#ensayos","title":"Ensayos","text":"<p>Kubernetes monitorea los pods para verificar que estos funcionen. Para ellos habilita dos ensayos:  uno de arranque (<code>readinessProbe</code>)  y otro de disponibilidad (<code>livenessProbe</code>).</p> <p>Cada ensayo es configurado por separado:</p> <p><pre><code># ...\nspec:\n  containers:\n    # ...   \n    readinessProbe:\n      httpGet:\n        path: /\n        port: 80\n      initialDelaySeconds: 5\n      periodSeconds: 10\n    livenessProbe:\n      tcpSocket:\n        port: 80\n      initialDelaySeconds: 15\n      periodSeconds: 20\n</code></pre> y habilita a elegir el protocolo a usar, rutas, n\u00famero de puertos, etc.</p> <p>Debido a que los pods suelen requerir un tiempo apreciable para ponerse en marcha es conveniente definir un retardo inicial para los ensayos (<code>initialDelaySeconds</code>) adem\u00e1s del tiempo entre testeos (<code>periodSeconds</code>)</p>","tags":["Kubernetes"]},{"location":"k8s/manifiesto/#leer-manifiesto","title":"Leer manifiesto","text":"<p>El manifiesto de un pod preexistente se consulta as\u00ed:</p> <pre><code>kubectl get pod nginx -o yaml\n</code></pre>","tags":["Kubernetes"]},{"location":"k8s/secrets/","title":"Secrets","text":"<p>Los los valores secretos van codificados en base64</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: db-credentials\ntype: Opaque\ndata: \n  username: YWRtaW4=                # 'admin'\n  password: c3VwM3JwYXNzdzByZA==    # 'sup3rpassw0rd'\n\n# Esto se puede crear a mano:\n# kubectl create secret generic db-credentials --from-literal=username=admin --from-literal=password=sup3rpassw0rd\n# Docs: https://kubernetes.io/es/docs/concepts/configuration/secret/\n</code></pre> <pre><code>apiVersion: v1\nkind: Pod\nmetadata:\n  name: nginx\nspec:\n  containers:\n  - name: nginx\n    image: nginx:alpine\n    env:\n    - name: MI_VARIABLE\n      value: \"pelado\"\n    - name: MYSQL_USER\n      valueFrom:\n        secretKeyRef:\n          name: db-credentials\n          key: username\n    - name: MYSQL_PASSWORD\n      valueFrom:\n        secretKeyRef:\n          name: db-credentials\n          key: password\n    ports:\n    - containerPort: 80\n</code></pre>","tags":["Kubernetes"]},{"location":"k8s/servicios/","title":"Servicios","text":"<ul> <li>Cluster IP</li> <li>Node Port</li> <li>Load Balancer</li> </ul>","tags":["Kubernetes"]},{"location":"k8s/servicios/#cluster-ip","title":"Cluster IP","text":"<p>En este manifiesto se crean un deployment y un servicio que crea una direcci\u00f3n IP privada con la cual se puede acceder a los pods internos. <pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: hello\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      role: hello\n  template:\n    metadata:\n      labels:\n        role: hello\n    spec:\n      containers:\n      - name: hello\n        image: gcr.io/google-samples/hello-app:1.0\n        ports:\n        - containerPort: 8080\n\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: hello\nspec:\n  ports:\n  - port: 8080\n    targetPort: 8080\n  selector:\n    role: hello\n</code></pre></p> <p>Los puertos de los contenedores internos van variando seg\u00fan son creados.  El servicio va buscando y conectando a esos contenedores internos. El tipo por defecto de los servicios es <code>CLusterIP</code>, por eso no se indica.</p>","tags":["Kubernetes"]},{"location":"k8s/servicios/#node-port","title":"Node Port","text":"<p>Este servicio expone un puerto especificado para cada nodo. Por lo dem\u00e1s es muy similar al servicio previo.</p> <pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: hello\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      role: hello\n  template:\n    metadata:\n      labels:\n        role: hello\n    spec:\n      containers:\n      - name: hello\n        image: gcr.io/google-samples/hello-app:1.0\n        ports:\n        - containerPort: 8080\n\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: hello\nspec:\n  type: NodePort            # tipo explicito\n  ports:\n  - port: 8080\n    targetPort: 8080\n    nodePort: 30000\n  selector:\n    role: hello\n</code></pre>","tags":["Kubernetes"]},{"location":"k8s/servicios/#load-balancer","title":"Load Balancer","text":"<pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: hello\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      role: hello\n  template:\n    metadata:\n      labels:\n        role: hello\n    spec:\n      containers:\n      - name: hello\n        image: gcr.io/google-samples/hello-app:1.0\n        ports:\n        - containerPort: 8080\n\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: hello\nspec:\n  type: LoadBalancer        # tipo explicito\n  ports:\n  - port: 8080\n    targetPort: 8080\n  selector:\n    role: hello\n</code></pre>","tags":["Kubernetes"]},{"location":"k8s/statefulset/","title":"StatefulSet","text":"<p>Estos manifiestos incluyen un volumen persistente.  De esta manera los datos no se pierden si alguno de los pods es eliminado.</p> <pre><code>apiVersion: apps/v1\nkind: StatefulSet\nmetadata:\n  name: my-csi-app-set\nspec:\n  selector:\n    matchLabels:\n      app: mypod\n  serviceName: \"my-frontend\"\n  replicas: 1\n  template:\n    metadata:\n      labels:\n        app: mypod\n    spec:\n      containers:\n      - name: my-frontend\n        image: busybox\n        args:\n        - sleep\n        - infinity\n        volumeMounts:\n        - mountPath: \"/data\"\n          name: csi-pvc\n  volumeClaimTemplates:\n  - metadata:\n      name: csi-pvc\n    spec:\n      accessModes:\n      - ReadWriteOnce\n      resources:\n        requests:\n          storage: 5Gi      # 5GiB de espacio en disco\n      storageClassName: do-block-storage\n</code></pre> <p>Kubernetes crea en el servidor remoto el volumen requerido de manera autom\u00e1tica.</p> <p>Nuevo comando: <code>describe</code></p> <pre><code>kubectl describe pod nombre_pod\n</code></pre> <p>PVC: Persistent Volume Claim</p> <p>Estos volumenes se listan con:</p> <pre><code>kubectl get pvc\n</code></pre> <p>Los manifiestos del tipo <code>StatefulSet</code> tienen su propia opc\u00edon de listado:</p> <pre><code>kubectl get statefulsets\nkubectl get sts\n</code></pre> <p>Eliminacion: <pre><code>kubectl delete sts nombre_sts\n</code></pre></p> <pre><code>kubectl delete pvc nombre_pvc\n</code></pre>","tags":["Kubernetes"]},{"location":"podman/pods/","title":"Pods","text":"<p>Las vainas o (pods) son una especie de contenedores auxiliares que sirven para englobar m\u00faltiples contenedores internos, creando unidades funcionales completas.</p> <p>Podman permite la creaci\u00f3n manual de pods en tanto que Docker no.</p> <p>Por otra parte, Kubernetes crea y usa pods de forma autom\u00e1tica: un pod por cada \"nodo\" (servidor f\u00edsico o l\u00f3gico) dedicado al procesamiento del software desplegado.</p>","tags":["Podman"]},{"location":"podman/pods/#crear-pods","title":"Crear pods","text":"<pre><code>podman pod create --name nombre_pod\n</code></pre> <pre><code>podman pod create --label nombre_pod\n</code></pre>","tags":["Podman"]},{"location":"podman/pods/#listar-pods","title":"Listar pods","text":"<pre><code>podman pod list\npodman pod ps \n</code></pre>","tags":["Podman"]},{"location":"podman/pods/#agregar-contenedores","title":"Agregar contenedores","text":"<pre><code>podman pod run -dt  --pod  nombre_pod   imagen:version  nombre_contenedor\n</code></pre> <pre><code>podman pod top nombre_pod\n</code></pre> <pre><code>podman pod stats -a --no-stream\n</code></pre> <pre><code>podman pod inspect nombre_pod\n</code></pre>","tags":["Podman"]},{"location":"podman/pods/#detener-contenedores","title":"Detener contenedores","text":"<pre><code>podman pod stop nombre_pod\n</code></pre>","tags":["Podman"]},{"location":"podman/pods/#listar-pods-y-contenedores","title":"Listar pods y contenedores","text":"<pre><code>podman ps -a --pod\n</code></pre>","tags":["Podman"]},{"location":"podman/pods/#eliminar-pods","title":"Eliminar pods","text":"<pre><code>podman pod rm nombre_pod\n</code></pre> <p>Pod de sitios MkDocs</p> <pre><code>podman pod create --label PaginasMkDocs\npodman pod run -dt  --pod  PaginasMkDocs docker.io/squidfunk/mkdocs-material:latest PythonDocs\n</code></pre>","tags":["Podman"]}]}